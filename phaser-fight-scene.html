<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brotherhood Boxing - Phaser 3 Fight Sim</title>
    <!-- Phaser 3 CDN Load -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', monospace;
            background: #0a0a0a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        #game-container {
            border: 4px solid #e94560;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.4);
        }
        .controls-info {
            margin-top: 15px;
            font-size: 10px;
            color: #888;
            text-align: center;
        }
        .controls-info span { color: #ffdd00; }
        .creator-panel {
            width: 640px;
            max-width: 95vw;
            background: rgba(0, 0, 0, 0.65);
            border: 3px solid #e94560;
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 12px;
            box-shadow: 0 0 18px rgba(233, 69, 96, 0.3);
            font-size: 10px;
            line-height: 1.6;
        }
        .creator-panel h2 {
            color: #ffdd00;
            font-size: 14px;
            margin-bottom: 8px;
            text-shadow: 2px 2px 0 #000;
        }
        .creator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            align-items: end;
        }
        .creator-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .creator-field label {
            color: #ccc;
            font-size: 9px;
            letter-spacing: 0.5px;
        }
        .creator-field input,
        .creator-field select {
            background: #0f0f1f;
            color: #fff;
            border: 2px solid #333;
            padding: 6px 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 9px;
        }
        .creator-field input[type="range"] {
            padding: 0;
        }
        .creator-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .creator-actions button {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, #4da6ff 0%, #0066cc 100%);
            color: #fff;
            border: 3px solid #fff;
            padding: 10px 16px;
            cursor: pointer;
            text-shadow: 1px 1px 0 #000;
            box-shadow: 0 0 12px rgba(0, 102, 204, 0.5);
        }
        .creator-actions .secondary {
            background: linear-gradient(180deg, #e94560 0%, #b83250 100%);
        }
        #game-container.crt {
            position: relative;
            overflow: hidden;
        }
        #game-container.crt::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0.05),
                rgba(255, 255, 255, 0.05) 2px,
                rgba(0, 0, 0, 0.05) 2px,
                rgba(0, 0, 0, 0.05) 4px
            );
            mix-blend-mode: overlay;
        }
        h1 {
            font-size: 24px;
            color: #e94560;
            margin-bottom: 15px;
            text-shadow: 3px 3px 0 #000;
        }
    </style>
</head>
<body>
    <h1>ðŸ¥Š BROTHERHOOD BOXING ðŸ¥Š</h1>
    <div class="creator-panel">
        <h2>RETRO PUNCH-OUT! SIM + CREATE-A-BOXER</h2>
        <form id="create-boxer-form">
            <div class="creator-grid">
                <div class="creator-field">
                    <label for="boxer-name">Boxer Name</label>
                    <input id="boxer-name" type="text" placeholder="Custom Bruiser" maxlength="18" aria-label="Custom boxer name">
                </div>
                <div class="creator-field">
                    <label for="boxer-style">Fighting Style</label>
                    <select id="boxer-style">
                        <option value="balanced">Balanced (Tyson vs. Holyfield ready)</option>
                        <option value="slugger">Slugger (power)</option>
                        <option value="outboxer">Out-Boxer (speed)</option>
                        <option value="counter">Counter (defense)</option>
                    </select>
                </div>
                <div class="creator-field">
                    <label for="palette-select">Palette</label>
                    <select id="palette-select">
                        <option value="crimson">Crimson Rush</option>
                        <option value="neon">Neon Blitz</option>
                        <option value="mint">Mint Guard</option>
                        <option value="sunset">Sunset Southpaw</option>
                    </select>
                </div>
                <div class="creator-field">
                    <label for="power-range">Power <span id="power-value" aria-live="polite">82</span></label>
                    <input id="power-range" type="range" min="50" max="99" step="1" value="82" aria-valuemin="50" aria-valuemax="99" aria-valuenow="82">
                </div>
                <div class="creator-field">
                    <label for="speed-range">Speed <span id="speed-value" aria-live="polite">88</span></label>
                    <input id="speed-range" type="range" min="50" max="99" step="1" value="88" aria-valuemin="50" aria-valuemax="99" aria-valuenow="88">
                </div>
                <div class="creator-field">
                    <label for="defense-range">Defense <span id="defense-value" aria-live="polite">80</span></label>
                    <input id="defense-range" type="range" min="50" max="99" step="1" value="80" aria-valuemin="50" aria-valuemax="99" aria-valuenow="80">
                </div>
                <div class="creator-field">
                    <label for="crt-toggle">Punch-Out! CRT Mode</label>
                    <select id="crt-toggle">
                        <option value="on">On (scanlines)</option>
                        <option value="off">Off</option>
                    </select>
                </div>
            </div>
            <div class="creator-actions" style="margin-top:10px;">
                <button type="submit">START RETRO BOUT</button>
                <button type="button" class="secondary" id="mirror-match">Mirror Match Tyson</button>
            </div>
        </form>
    </div>
    <div id="game-container"></div>
    <div class="controls-info">
        <span>SPACE</span> - Pause/Resume | <span>N</span> - Next Round | <span>R</span> - Restart | <span>Q</span> - Queue Corner Action
    </div>

<script>
// === RETRO PALETTE + CREATE-A-BOXER ===
const punchoutPalettes = {
    crimson: { trunk: '#e94560', glove: '#ffdd00', skin: '#d4a574', hair: '#1a1a1a' },
    neon: { trunk: '#00c2ff', glove: '#ff3df2', skin: '#c58c6a', hair: '#0b1d4d' },
    mint: { trunk: '#64f4ac', glove: '#1aaf5d', skin: '#e1b382', hair: '#2f1b10' },
    sunset: { trunk: '#ff9f1c', glove: '#ff004e', skin: '#b57b57', hair: '#3b2c35' }
};

function hexToInt(hex) {
    return parseInt(hex.replace('#', ''), 16);
}

// Style modifier baselines (tuned to evoke classic Punch-Out archetypes)
// Modifier scale: small adjustments in the range of -6 to +8 keep fighters within believable 50â€“99 stat bounds.
// Each style adds tradeoffs instead of hard advantages, preserving a â€œpick your flavorâ€ feel.
// Slugger: big power, slower hands, iron chin
const STYLE_MODS = {
    slugger: { strength: 8, speed: -5, agility: -2, chin: 4, heart: 92 },
    // Out-boxer: fleet footwork, lower power, lighter chin
    outboxer: { strength: -6, speed: 8, agility: 6, chin: -2, heart: 94 },
    // Counter: slick defense, solid chin, bonus defense
    counter: { strength: -2, speed: 0, agility: 4, chin: 6, defense: 8, heart: 96 },
    // Balanced: neutral, no penalties
    balanced: { strength: 0, speed: 0, agility: 0, chin: 0, heart: 95 }
};

// Clamp core fighter stats to the intended 50â€“99 bounds
function clampStat(value) {
    return Math.max(50, Math.min(99, value));
}

function buildStyleStats(style, power, speed, defense) {
    const mod = STYLE_MODS[style] || STYLE_MODS.balanced;
    return {
        strength: clampStat(power + (mod.strength || 0)),
        speed: clampStat(speed + (mod.speed || 0)),
        agility: clampStat(speed + (mod.agility || 0)),
        defense: clampStat(defense + (mod.defense || 0)),
        chin: clampStat(defense + (mod.chin || 0)),
        heart: mod.heart || 95
    };
}

function applyCRTMode(enabled) {
    const container = document.getElementById('game-container');
    if (enabled) {
        container.classList.add('crt');
    } else {
        container.classList.remove('crt');
    }
}

function startCustomBout(options = {}) {
    const name = options.name || 'Custom Bruiser';
    const palette = punchoutPalettes[options.paletteKey] || punchoutPalettes.crimson;
    const power = options.power ?? 82;
    const speed = options.speed ?? 88;
    const defense = options.defense ?? 80;
    const styleStats = buildStyleStats(options.style || 'balanced', power, speed, defense);

    const tysonPalette = punchoutPalettes.sunset;
    const fighter2Config = {
        name: 'Mike Tyson',
        health: 100, maxHealth: 100,
        stamina: 100, maxStamina: 100,
        strength: 98, agility: 88, speed: 98,
        defense: 88, chin: 92, heart: 94,
        trunkColor: hexToInt(tysonPalette.trunk),
        skinColor: hexToInt(tysonPalette.skin),
        gloveColor: hexToInt(tysonPalette.glove),
        hairColor: hexToInt(tysonPalette.hair)
    };

    const fighter1Config = options.mirrorTyson ? { ...fighter2Config } : {
        name,
        health: 100, maxHealth: 100,
        stamina: 100, maxStamina: 100,
        ...styleStats,
        trunkColor: hexToInt(palette.trunk),
        skinColor: hexToInt(palette.skin),
        gloveColor: hexToInt(palette.glove),
        hairColor: hexToInt(palette.hair)
    };

    applyCRTMode(options.crt !== 'off');

    if (window.BrotherhoodBoxing?.startFight) {
        window.BrotherhoodBoxing.startFight(fighter1Config, fighter2Config);
    }
}

document.getElementById('create-boxer-form').addEventListener('submit', (e) => {
    e.preventDefault();
    startCustomBout({
        name: document.getElementById('boxer-name').value || 'Custom Bruiser',
        paletteKey: document.getElementById('palette-select').value,
        style: document.getElementById('boxer-style').value,
        power: Number(document.getElementById('power-range').value),
        speed: Number(document.getElementById('speed-range').value),
        defense: Number(document.getElementById('defense-range').value),
        crt: document.getElementById('crt-toggle').value
    });
});

document.getElementById('mirror-match').addEventListener('click', () => {
    startCustomBout({
        name: 'Mike Tyson',
        paletteKey: 'sunset',
        style: 'slugger',
        power: 98,
        speed: 98,
        defense: 88,
        mirrorTyson: true,
        crt: document.getElementById('crt-toggle').value
    });
});

// Live range value display for accessibility
const powerRangeEl = document.getElementById('power-range');
const speedRangeEl = document.getElementById('speed-range');
const defenseRangeEl = document.getElementById('defense-range');
const powerValueEl = document.getElementById('power-value');
const speedValueEl = document.getElementById('speed-value');
const defenseValueEl = document.getElementById('defense-value');

function bindRange(rangeEl, valueEl) {
    if (!rangeEl || !valueEl) return;
    rangeEl.addEventListener('input', () => {
        valueEl.textContent = rangeEl.value;
        rangeEl.setAttribute('aria-valuenow', rangeEl.value);
    });
}

bindRange(powerRangeEl, powerValueEl);
bindRange(speedRangeEl, speedValueEl);
bindRange(defenseRangeEl, defenseValueEl);

/**
 * FighterRenderer Class - Exportable module for procedural pixel sprite rendering
 * Renders 64x96px boxing fighters with orthodox stance (SEGA character level)
 * Features: 7-level damage system, frame interpolation, hit-stop effects
 */
class FighterRenderer {
    // Animation constants
    static TARGET_FPS = 60;
    static TARGET_FRAME_TIME = 1000 / FighterRenderer.TARGET_FPS; // 16.6ms
    static FRAME_INTERPOLATION_SPEED = 0.15;
    
    // Damage system constants
    static MAX_DAMAGE = 100;
    static DAMAGE_LEVELS = 7;
    static DAMAGE_PER_LEVEL = FighterRenderer.MAX_DAMAGE / FighterRenderer.DAMAGE_LEVELS; // Damage threshold per level
    
    // Hit-stop effect constants
    static MIN_HIT_STOP_FRAMES = 2;
    static HIT_STOP_ADDITIONAL_FRAMES = 3; // Random 0-2 added to MIN (results in 2-4 total frames)
    static HIT_STOP_DAMAGE_DIVISOR = 8;
    
    constructor(scene, x, y, config = {}) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.config = {
            trunkColor: config.trunkColor || 0xff0000,
            skinColor: config.skinColor || 0xd4a574,
            gloveColor: config.gloveColor || 0x8b0000,
            hairColor: config.hairColor || 0x1a1a1a,
            facing: config.facing || 'right', // 'left' or 'right'
            scale: config.scale || 1,
            ...config
        };
        
        this.graphics = scene.add.graphics();
        this.state = 'idle';
        this.frame = 0;
        this.frameTimer = 0;
        this.swelling = 0;
        this.damageFlash = 0;
        
        // 7-level damage system (0=fresh, 6=critical)
        this.damageLevel = 0;
        this.totalDamage = 0;
        
        // Frame interpolation for smooth transitions
        this.prevState = 'idle';
        this.stateTransition = 0;
        this.transitionSpeed = FighterRenderer.FRAME_INTERPOLATION_SPEED;
        
        // Hit-stop effect
        this.hitStopFrames = 0;
        
        // Animation state with interpolation targets
        this.armOffset = { left: 0, right: 0 };
        this.bodyOffset = { x: 0, y: 0 };
        this.headOffset = { x: 0, y: 0 };
        this.targetArmOffset = { left: 0, right: 0 };
        this.targetBodyOffset = { x: 0, y: 0 };
        this.targetHeadOffset = { x: 0, y: 0 };
        
        this.render();
    }
    
    /**
     * Render the fighter using procedural pixel art (fillRect style)
     * 64x96px SEGA character level with 7-level damage system
     */
    render() {
        const g = this.graphics;
        const c = this.config;
        const flip = c.facing === 'left' ? -1 : 1;
        
        g.clear();
        g.setPosition(this.x + this.bodyOffset.x, this.y + this.bodyOffset.y);
        
        // Apply damage flash
        const flashMod = this.damageFlash > 0 ? 0xffffff : 0;
        
        // Scale factor (adjusted for 64x96px sprite)
        const s = c.scale;
        
        // Get damage visual effects (7-level system)
        const damageEffects = this.getDamageEffects();
        
        // === LEGS (bottom layer) - proportionally adjusted for 96px height ===
        // Left leg
        g.fillStyle(this.applyFlash(this.applyDamageColor(c.skinColor, damageEffects), flashMod));
        g.fillRect(-12 * s * flip, 30 * s, 10 * s, 22 * s);
        // Right leg
        g.fillRect(2 * s * flip, 30 * s, 10 * s, 22 * s);
        
        // Shoes
        g.fillStyle(this.applyFlash(0x1a1a1a, flashMod));
        g.fillRect(-14 * s * flip, 50 * s, 14 * s, 6 * s);
        g.fillRect(0 * s * flip, 50 * s, 14 * s, 6 * s);
        
        // === TRUNKS (shorts) ===
        g.fillStyle(this.applyFlash(c.trunkColor, flashMod));
        g.fillRect(-16 * s * flip, 24 * s, 32 * s, 10 * s);
        // Waistband
        g.fillStyle(this.applyFlash(this.darkenColor(c.trunkColor), flashMod));
        g.fillRect(-16 * s * flip, 22 * s, 32 * s, 3 * s);
        
        // === TORSO ===
        g.fillStyle(this.applyFlash(this.applyDamageColor(c.skinColor, damageEffects), flashMod));
        g.fillRect(-14 * s * flip, 0, 28 * s, 26 * s);
        // Chest definition
        g.fillStyle(this.applyFlash(this.darkenColor(this.applyDamageColor(c.skinColor, damageEffects), 0.1), flashMod));
        g.fillRect(-10 * s * flip, 3 * s, 8 * s, 8 * s);
        g.fillRect(2 * s * flip, 3 * s, 8 * s, 8 * s);
        
        // === ARMS ===
        // Left arm (guard position or punch)
        const leftArmX = -20 * s * flip + this.armOffset.left * flip;
        const leftArmY = 3 * s;
        g.fillStyle(this.applyFlash(this.applyDamageColor(c.skinColor, damageEffects), flashMod));
        g.fillRect(leftArmX, leftArmY, 10 * s, 18 * s);
        
        // Left glove
        g.fillStyle(this.applyFlash(c.gloveColor, flashMod));
        g.fillRect(leftArmX - 2 * s, leftArmY - 3 * s + this.armOffset.left * 0.3, 14 * s, 14 * s);
        
        // Right arm
        const rightArmX = 10 * s * flip + this.armOffset.right * flip;
        const rightArmY = 3 * s;
        g.fillStyle(this.applyFlash(this.applyDamageColor(c.skinColor, damageEffects), flashMod));
        g.fillRect(rightArmX, rightArmY, 10 * s, 18 * s);
        
        // Right glove
        g.fillStyle(this.applyFlash(c.gloveColor, flashMod));
        g.fillRect(rightArmX - 2 * s, rightArmY - 3 * s + this.armOffset.right * 0.3, 14 * s, 14 * s);
        
        // === HEAD ===
        const headX = -12 * s * flip + this.headOffset.x;
        const headY = -28 * s + this.headOffset.y;
        
        // Head shape
        g.fillStyle(this.applyFlash(this.applyDamageColor(c.skinColor, damageEffects), flashMod));
        g.fillRect(headX, headY, 24 * s, 22 * s);
        
        // Hair
        g.fillStyle(this.applyFlash(c.hairColor, flashMod));
        g.fillRect(headX, headY - 3 * s, 24 * s, 6 * s);
        
        // Eyes - vary with damage level
        const eyeDisplayColor = this.getEyeColorByDamage();
        g.fillStyle(this.applyFlash(eyeDisplayColor, flashMod));
        if (c.facing === 'right') {
            g.fillRect(headX + 4 * s, headY + 8 * s, 5 * s, 3 * s);
            g.fillRect(headX + 13 * s, headY + 8 * s, 5 * s, 3 * s);
        } else {
            g.fillRect(headX + 2 * s, headY + 8 * s, 5 * s, 3 * s);
            g.fillRect(headX + 11 * s, headY + 8 * s, 5 * s, 3 * s);
        }
        
        // Nose
        g.fillStyle(this.applyFlash(this.darkenColor(this.applyDamageColor(c.skinColor, damageEffects), 0.15), flashMod));
        g.fillRect(headX + 9 * s, headY + 11 * s, 4 * s, 5 * s);
        
        // Mouth - changes with damage
        const mouthColor = damageEffects.bleeding ? 0xff0000 : 0x8b4513;
        g.fillStyle(this.applyFlash(mouthColor, flashMod));
        g.fillRect(headX + 7 * s, headY + 17 * s, 8 * s, 2 * s);
        
        // Draw damage-specific visual effects
        this.renderDamageEffects(g, headX, headY, s, damageEffects);
    }
    
    /**
     * Get 7-level damage effects
     * Level 0: Fresh - no visible damage
     * Level 1: Light - minor swelling
     * Level 2: Moderate - visible bruising
     * Level 3: Heavy - significant swelling, cut
     * Level 4: Severe - heavy bruising, bleeding
     * Level 5: Critical - heavily damaged, discoloration
     * Level 6: Near KO - extreme damage, barely standing
     */
    getDamageEffects() {
        return {
            level: this.damageLevel,
            swelling: this.damageLevel * 15,
            bruising: this.damageLevel >= 2,
            cut: this.damageLevel >= 3,
            bleeding: this.damageLevel >= 4,
            discoloration: this.damageLevel >= 5,
            severe: this.damageLevel >= 6
        };
    }
    
    /**
     * Apply damage color tint based on damage level
     */
    applyDamageColor(baseColor, effects) {
        if (effects.level === 0) return baseColor;
        
        const r = (baseColor >> 16) & 0xff;
        const g = (baseColor >> 8) & 0xff;
        const b = baseColor & 0xff;
        
        // Progressive darkening and reddening with damage
        const darkenFactor = 1 - (effects.level * 0.08);
        const redBoost = effects.level * 8;
        
        const newR = Math.min(255, Math.floor(r * darkenFactor + redBoost));
        const newG = Math.floor(g * darkenFactor);
        const newB = Math.floor(b * darkenFactor);
        
        return (newR << 16) | (newG << 8) | newB;
    }
    
    /**
     * Get eye color based on damage level
     */
    getEyeColorByDamage() {
        if (this.damageLevel >= 5) return 0x660066; // Purple/swollen
        if (this.damageLevel >= 3) return 0x4a4a4a; // Darkened
        return 0x1a1a1a; // Normal
    }
    
    /**
     * Render damage-specific visual effects (bruises, cuts, blood)
     */
    renderDamageEffects(g, headX, headY, s, effects) {
        // Swelling/bruising
        if (effects.bruising) {
            g.fillStyle(0x9932cc);
            g.setAlpha(0.4 + effects.level * 0.05);
            const swellSize = effects.swelling * 0.5 * s;
            g.fillRect(headX + 2 * s, headY + 6 * s, swellSize, swellSize);
            g.setAlpha(1);
        }
        
        // Cuts
        if (effects.cut) {
            g.fillStyle(0x8b0000);
            g.fillRect(headX + 3 * s, headY + 5 * s, 8 * s, 1 * s);
        }
        
        // Bleeding
        if (effects.bleeding) {
            g.fillStyle(0xff0000);
            g.setAlpha(0.6);
            g.fillRect(headX + 4 * s, headY + 6 * s, 2 * s, 8 * s);
            g.setAlpha(1);
        }
        
        // Severe discoloration
        if (effects.discoloration) {
            g.fillStyle(0x4a0e4e);
            g.setAlpha(0.3);
            g.fillRect(headX, headY, 24 * s, 22 * s);
            g.setAlpha(1);
        }
    }
    
    /**
     * Update animation frame with hit-stop and frame interpolation
     */
    update(delta) {
        // Hit-stop effect (pause animation on heavy hits)
        if (this.hitStopFrames > 0) {
            this.hitStopFrames--;
            this.render(); // Still render but don't advance animation
            return;
        }
        
        this.frameTimer += delta;
        
        // 60 FPS animation using TARGET_FRAME_TIME constant
        if (this.frameTimer > FighterRenderer.TARGET_FRAME_TIME) {
            this.frameTimer = 0;
            this.frame = (this.frame + 1) % 12;
            this.updateAnimationState();
        }
        
        // Frame interpolation for smooth transitions
        this.applyFrameInterpolation();
        
        // Decay damage flash
        if (this.damageFlash > 0) {
            this.damageFlash -= delta * 0.01;
        }
        
        this.render();
    }
    
    /**
     * Apply frame interpolation for smooth stance transitions
     */
    applyFrameInterpolation() {
        // Interpolate arm positions
        this.armOffset.left += (this.targetArmOffset.left - this.armOffset.left) * this.transitionSpeed;
        this.armOffset.right += (this.targetArmOffset.right - this.armOffset.right) * this.transitionSpeed;
        
        // Interpolate body positions
        this.bodyOffset.x += (this.targetBodyOffset.x - this.bodyOffset.x) * this.transitionSpeed;
        this.bodyOffset.y += (this.targetBodyOffset.y - this.bodyOffset.y) * this.transitionSpeed;
        
        // Interpolate head positions
        this.headOffset.x += (this.targetHeadOffset.x - this.headOffset.x) * this.transitionSpeed;
        this.headOffset.y += (this.targetHeadOffset.y - this.headOffset.y) * this.transitionSpeed;
    }
    
    /**
     * Update animation based on current state with keyframe structure:
     * Windup (2-4f) â†’ Action (2-4f) â†’ Impact (1-2f) â†’ Recovery (1-2f)
     */
    updateAnimationState() {
        const breathOffset = Math.sin(this.frame * 0.5) * 2;
        
        switch (this.state) {
            case 'idle':
                this.targetArmOffset.left = breathOffset;
                this.targetArmOffset.right = -breathOffset;
                this.targetBodyOffset.y = Math.sin(this.frame * 0.3) * 1;
                this.targetHeadOffset.x = 0;
                this.targetHeadOffset.y = 0;
                break;
                
            case 'jab':
                // 8 frame jab: Windup(2f) â†’ Action(3f) â†’ Impact(1f) â†’ Recovery(2f)
                const jabProgress = (this.frame % 8) / 8;
                if (jabProgress < 0.25) {
                    // Windup (2 frames)
                    this.targetArmOffset.left = jabProgress * 80;
                    this.targetBodyOffset.x = -2;
                } else if (jabProgress < 0.625) {
                    // Action (3 frames)
                    this.targetArmOffset.left = 20 + (jabProgress - 0.25) * 160;
                    this.targetBodyOffset.x = 3;
                } else if (jabProgress < 0.75) {
                    // Impact (1 frame)
                    this.targetArmOffset.left = 80;
                    this.targetBodyOffset.x = 5;
                } else {
                    // Recovery (2 frames)
                    this.targetArmOffset.left = 80 - (jabProgress - 0.75) * 320;
                    this.targetBodyOffset.x = 5 - (jabProgress - 0.75) * 20;
                }
                this.targetArmOffset.right = -5;
                break;
                
            case 'hook':
                // 10 frame hook: Windup(3f) â†’ Action(4f) â†’ Impact(1f) â†’ Recovery(2f)
                const hookProgress = (this.frame % 10) / 10;
                if (hookProgress < 0.3) {
                    // Windup (3 frames)
                    this.targetArmOffset.right = -25;
                    this.targetBodyOffset.x = -8;
                } else if (hookProgress < 0.7) {
                    // Action (4 frames)
                    this.targetArmOffset.right = -25 + (hookProgress - 0.3) * 212.5;
                    this.targetBodyOffset.x = -8 + (hookProgress - 0.3) * 45;
                } else if (hookProgress < 0.8) {
                    // Impact (1 frame)
                    this.targetArmOffset.right = 60;
                    this.targetBodyOffset.x = 10;
                } else {
                    // Recovery (2 frames)
                    this.targetArmOffset.right = 60 - (hookProgress - 0.8) * 300;
                    this.targetBodyOffset.x = 10 - (hookProgress - 0.8) * 50;
                }
                break;
                
            case 'uppercut':
                // 12 frame uppercut: Windup(3f) â†’ Action(4f) â†’ Impact(2f) â†’ Recovery(3f)
                const upperProgress = (this.frame % 12) / 12;
                if (upperProgress < 0.25) {
                    // Windup (3 frames)
                    this.targetBodyOffset.y = 12;
                    this.targetArmOffset.right = -15;
                } else if (upperProgress < 0.583) {
                    // Action (4 frames)
                    this.targetBodyOffset.y = 12 - (upperProgress - 0.25) * 81;
                    this.targetArmOffset.right = -15 + (upperProgress - 0.25) * 195;
                    this.targetHeadOffset.y = -8;
                } else if (upperProgress < 0.75) {
                    // Impact (2 frames)
                    this.targetBodyOffset.y = -15;
                    this.targetArmOffset.right = 50;
                    this.targetHeadOffset.y = -10;
                } else {
                    // Recovery (3 frames)
                    this.targetBodyOffset.y = -15 + (upperProgress - 0.75) * 60;
                    this.targetArmOffset.right = 50 - (upperProgress - 0.75) * 200;
                    this.targetHeadOffset.y = -10 + (upperProgress - 0.75) * 40;
                }
                break;
                
            case 'block':
                // Static block pose with slight movement
                this.targetArmOffset.left = -15 + breathOffset * 0.5;
                this.targetArmOffset.right = -15 - breathOffset * 0.5;
                this.targetBodyOffset.y = 5;
                break;
                
            case 'knockdown':
                // 12 frame knockdown
                const kdProgress = Math.min(this.frame / 12, 1);
                this.targetBodyOffset.x = kdProgress * 30 * (this.config.facing === 'right' ? -1 : 1);
                this.targetBodyOffset.y = kdProgress * 60;
                this.targetHeadOffset.x = kdProgress * 10;
                this.targetArmOffset.left = kdProgress * 30;
                this.targetArmOffset.right = kdProgress * 40;
                break;
                
            case 'damaged':
                // Stagger animation
                const dmgOscillate = Math.sin(this.frame * 2) * 5;
                this.targetHeadOffset.x = dmgOscillate;
                this.targetBodyOffset.x = dmgOscillate * 0.5;
                break;
        }
    }
    
    /**
     * Set animation state with smooth transition
     */
    setState(newState) {
        if (this.state !== newState) {
            this.prevState = this.state;
            this.state = newState;
            this.frame = 0;
        }
    }
    
    /**
     * Apply damage with 7-level system and visual effects
     */
    takeDamage(amount, isHeavy = false) {
        this.damageFlash = 1;
        this.swelling = Math.min(100, this.swelling + amount * 0.5);
        this.totalDamage += amount;
        
        // Update damage level (7 levels: 0-6) using DAMAGE_PER_LEVEL constant
        this.damageLevel = Math.min(
            FighterRenderer.DAMAGE_LEVELS - 1, 
            Math.floor(this.totalDamage / FighterRenderer.DAMAGE_PER_LEVEL)
        );
        
        // Apply hit-stop effect on heavy punches (2-4 frames)
        if (isHeavy) {
            const stopFrames = FighterRenderer.MIN_HIT_STOP_FRAMES + 
                              Math.floor(Math.random() * FighterRenderer.HIT_STOP_ADDITIONAL_FRAMES);
            this.hitStopFrames = stopFrames;
        }
    }
    
    /**
     * Trigger hit-stop effect for impactful moments
     * @param {number} damage - Optional damage amount to scale hit-stop duration
     */
    triggerHitStop(frames = null, damage = 0) {
        if (frames !== null) {
            // Direct frame count specified
            this.hitStopFrames = Math.max(this.hitStopFrames, frames);
        } else if (damage > 0) {
            // Calculate based on damage
            const calculatedFrames = FighterRenderer.MIN_HIT_STOP_FRAMES + 
                                    Math.floor(damage / FighterRenderer.HIT_STOP_DAMAGE_DIVISOR);
            this.hitStopFrames = Math.max(this.hitStopFrames, calculatedFrames);
        }
    }
    
    /**
     * Set position
     */
    setPosition(x, y) {
        this.x = x;
        this.y = y;
    }
    
    /**
     * Color utility - darken
     */
    darkenColor(color, factor = 0.2) {
        const r = ((color >> 16) & 0xff) * (1 - factor);
        const g = ((color >> 8) & 0xff) * (1 - factor);
        const b = (color & 0xff) * (1 - factor);
        return (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
    }
    
    /**
     * Color utility - apply flash
     */
    applyFlash(color, flash) {
        if (flash === 0) return color;
        const r = Math.min(255, ((color >> 16) & 0xff) + 100);
        const g = Math.min(255, ((color >> 8) & 0xff) + 100);
        const b = Math.min(255, (color & 0xff) + 100);
        return (r << 16) | (g << 8) | b;
    }
    
    /**
     * Destroy graphics
     */
    destroy() {
        this.graphics.destroy();
    }
}

/**
 * Fighter Class - Stats and combat logic
 */
class Fighter {
    constructor(config) {
        this.name = config.name || 'Fighter';
        this.health = config.health || 100;
        this.maxHealth = config.maxHealth || 100;
        this.stamina = config.stamina || 100;
        this.maxStamina = config.maxStamina || 100;
        
        // Core stats (0-100)
        this.strength = config.strength || 70;
        this.agility = config.agility || 70;
        this.speed = config.speed || 70;
        this.defense = config.defense || 70;
        this.chin = config.chin || 70; // Resistance to KO
        this.heart = config.heart || 70; // Recovery ability
        
        // Combat state
        this.knockdowns = 0;
        this.roundScore = 0;
        this.isDown = false;
        
        // Corner action queue
        this.actionQueue = [];
        this.currentStrategy = 'balanced';
    }
    
    /**
     * Queue a corner action
     * @param {Object} action - {action: 'jab'|'hook'|'uppercut'|'block', target: 'head'|'body', intensity: 0-100}
     */
    queueAction(action) {
        this.actionQueue.push(action);
    }
    
    /**
     * Get next action from queue or generate based on stats
     */
    getNextAction() {
        if (this.actionQueue.length > 0) {
            return this.actionQueue.shift();
        }
        
        // Auto-generate action based on stats and strategy
        return this.generateAutoAction();
    }
    
    /**
     * Generate automatic action based on fighter stats
     */
    generateAutoAction() {
        const roll = Math.random() * 100;
        const staminaFactor = this.stamina / 100;
        
        // Minimum stamina required for attacks
        const staminaCosts = { jab: 3, hook: 8, uppercut: 12, block: 2 };
        
        // Strategy modifiers
        let aggressionMod = 1;
        let defenseMod = 1;
        
        switch (this.currentStrategy) {
            case 'aggressive':
                aggressionMod = 1.5;
                defenseMod = 0.5;
                break;
            case 'defensive':
                aggressionMod = 0.5;
                defenseMod = 2;
                break;
            case 'body':
                aggressionMod = 1.2;
                break;
            case 'head':
                aggressionMod = 1.3;
                break;
        }
        
        // Action selection based on weighted RNG and stats
        // If stamina is too low for an action, set its chance to 0
        const jabChance = this.stamina >= staminaCosts.jab ? 
            (this.speed * 0.5 + this.agility * 0.3) * staminaFactor * aggressionMod : 0;
        const hookChance = this.stamina >= staminaCosts.hook ? 
            (this.strength * 0.4 + this.speed * 0.2) * staminaFactor * aggressionMod : 0;
        const uppercutChance = this.stamina >= staminaCosts.uppercut ? 
            (this.strength * 0.5) * staminaFactor * aggressionMod * 0.5 : 0;
        const blockChance = this.defense * defenseMod * staminaFactor;
        
        const total = jabChance + hookChance + uppercutChance + blockChance;
        
        // If total is 0 (completely exhausted), force block
        if (total <= 0) {
            return { action: 'block', target: 'head', intensity: 30 };
        }
        
        const normalized = roll / 100 * total;
        
        let action, target, intensity;
        
        if (normalized < jabChance) {
            action = 'jab';
            intensity = 40 + Math.random() * 30;
        } else if (normalized < jabChance + hookChance) {
            action = 'hook';
            intensity = 60 + Math.random() * 30;
        } else if (normalized < jabChance + hookChance + uppercutChance) {
            action = 'uppercut';
            intensity = 70 + Math.random() * 30;
        } else {
            action = 'block';
            intensity = 50 + this.defense * 0.3;
        }
        
        // Target selection
        target = this.currentStrategy === 'body' ? 'body' : 
                 this.currentStrategy === 'head' ? 'head' :
                 Math.random() > 0.5 ? 'head' : 'body';
        
        return { action, target, intensity: Math.min(100, intensity) };
    }
    
    /**
     * Calculate damage dealt
     * Note: Uses 70 as baseline stat value (fighters with 70 in a stat have 1.0x multiplier)
     * This creates a meaningful distribution: 50 = 0.71x, 70 = 1.0x, 100 = 1.43x
     */
    calculateDamage(action, intensity) {
        const baseDamage = {
            jab: 5,
            hook: 12,
            uppercut: 18,
            block: 0
        };
        
        // 70 is the baseline stat value (1.0x multiplier)
        const strengthMod = this.strength / 70;
        const intensityMod = intensity / 70;
        
        return Math.floor(baseDamage[action] * strengthMod * intensityMod);
    }
    
    /**
     * Take damage
     */
    takeDamage(damage, target) {
        // Defense reduction
        const defenseReduction = this.defense / 200;
        const actualDamage = Math.max(1, damage * (1 - defenseReduction));
        
        this.health = Math.max(0, this.health - actualDamage);
        
        // TKO check - if health reaches 0
        if (this.health <= 0 && !this.isDown) {
            this.knockdowns++;
            this.isDown = true;
            return 'knockdown';
        }
        
        // KO check based on chin stat (for head shots)
        if (target === 'head' && damage > 15) {
            // Use effective chin with minimum of 0.1 to avoid near-infinite KO chance
            const effectiveChin = Math.max(0.1, this.chin);
            const koChance = (damage - 10) / effectiveChin;
            if (Math.random() < koChance && !this.isDown) {
                this.knockdowns++;
                this.isDown = true;
                return 'knockdown';
            }
        }
        
        return actualDamage > 8 ? 'heavy' : actualDamage > 4 ? 'medium' : 'light';
    }
    
    /**
     * Check dodge based on speed and agility
     */
    attemptDodge() {
        // Base dodge from speed and agility (max ~40% at 100/100)
        let dodgeChance = (this.speed * 0.2 + this.agility * 0.2) / 100;

        // Stamina modifier: at 0 stamina keep 50% of base, at full keep 100%
        if (typeof this.maxStamina === 'number' && this.maxStamina > 0) {
            const staminaRatio = this.stamina / this.maxStamina;
            const staminaFactor = 0.5 + 0.5 * Math.max(0, Math.min(1, staminaRatio));
            dodgeChance *= staminaFactor;
        }

        // Health modifier: below 100 health reduces dodge effectiveness
        const healthRatio = Math.max(0, Math.min(1, this.health / 100));
        const healthFactor = 0.5 + 0.5 * healthRatio;
        dodgeChance *= healthFactor;

        // Clamp to a reasonable upper bound
        dodgeChance = Math.max(0, Math.min(0.5, dodgeChance));
        
        return Math.random() < dodgeChance;
    }
    
    /**
     * Use stamina
     */
    useStamina(amount) {
        this.stamina = Math.max(0, this.stamina - amount);
    }
    
    /**
     * Recover stamina (between rounds)
     */
    recoverStamina(amount) {
        const heartBonus = this.heart / 100;
        this.stamina = Math.min(this.maxStamina, this.stamina + amount * (1 + heartBonus));
    }
    
    /**
     * Reset for new round
     */
    resetRound() {
        this.roundScore = 0;
        this.recoverStamina(20);
    }
}

/**
 * FightScene - Main Phaser Scene for boxing simulation
 */
class FightScene extends Phaser.Scene {
    // Screen shake constants (SEGA character level spec)
    static SHAKE_INTENSITY_DIVISOR = 70;
    static MAX_SHAKE_INTENSITY = 0.018;
    static SHAKE_DURATION_MULTIPLIER = 10;
    static BASE_SHAKE_DURATION = 100;
    static MAX_SHAKE_DURATION = 400;
    static CRITICAL_INTENSITY_MULTIPLIER = 1.8;
    static CRITICAL_DURATION_MULTIPLIER = 1.4;
    static HEAVY_PUNCH_INTENSITY_MULTIPLIER = 1.5;
    static HEAVY_PUNCH_THRESHOLD = 12;
    
    constructor() {
        super({ key: 'FightScene' });
    }
    
    init(data) {
        // Fighter configurations (can be passed from manager UI)
        this.fighter1Config = data?.fighter1 || {
            name: 'Muhammad Ali',
            health: 100, maxHealth: 100,
            stamina: 100, maxStamina: 100,
            strength: 86, agility: 95, speed: 99,
            defense: 97, chin: 98, heart: 99,
            trunkColor: 0xff0000, skinColor: 0xd4a574
        };
        
        this.fighter2Config = data?.fighter2 || {
            name: 'Mike Tyson',
            health: 100, maxHealth: 100,
            stamina: 100, maxStamina: 100,
            strength: 98, agility: 88, speed: 98,
            defense: 88, chin: 92, heart: 94,
            trunkColor: 0x0066cc, skinColor: 0xa0826d
        };
    }
    
    create() {
        // === GAME STATE ===
        this.isPaused = false;
        this.currentRound = 1;
        this.maxRounds = 3;
        this.roundTime = 180; // 3 minutes in seconds
        this.roundTimer = this.roundTime;
        this.isRoundActive = true;
        this.isFightOver = false;
        
        // Scoring
        this.scores = { fighter1: [], fighter2: [] };
        
        // === GRAPHICS SPEC ENHANCEMENTS ===
        // Momentum system (per spec: slides left/right based on exchanges)
        this.momentum = 0; // -100 to 100, negative = fighter2 advantage
        
        // Combo tracking (per spec: HIT x[NUMBER] counter)
        this.comboCount = { fighter1: 0, fighter2: 0 };
        this.comboTimer = { fighter1: 0, fighter2: 0 };
        
        // Blood decals tracking (per spec: persistent with fade)
        this.bloodDecals = [];
        
        // Camera flash timing (per spec: 3-5 per second during big hits)
        this.cameraFlashCooldown = 0;
        
        // === CREATE RING BACKGROUND ===
        this.createRingBackground();
        
        // === CREATE CROWD LAYER (per spec) ===
        this.createCrowdLayer();
        
        // === CREATE FIGHTERS ===
        this.fighter1 = new Fighter(this.fighter1Config);
        this.fighter2 = new Fighter(this.fighter2Config);
        
        // Adjusted positions for 640x448 resolution
        this.renderer1 = new FighterRenderer(this, 200, 280, {
            trunkColor: this.fighter1Config.trunkColor || 0xff0000,
            skinColor: this.fighter1Config.skinColor || 0xd4a574,
            gloveColor: this.fighter1Config.gloveColor || 0x8b0000,
            hairColor: this.fighter1Config.hairColor || 0x1a1a1a,
            facing: 'right',
            scale: 1.3
        });
        
        this.renderer2 = new FighterRenderer(this, 440, 280, {
            trunkColor: this.fighter2Config.trunkColor || 0x0066cc,
            skinColor: this.fighter2Config.skinColor || 0xa0826d,
            gloveColor: this.fighter2Config.gloveColor || 0x00008b,
            hairColor: this.fighter2Config.hairColor || 0x1a1a1a,
            facing: 'left',
            scale: 1.3
        });
        
        // === CREATE REFEREE (per spec) ===
        this.createReferee();
        
        // === CREATE HUD (enhanced per spec) ===
        this.createHUD();
        
        // === CREATE PARTICLES (enhanced per spec) ===
        this.createParticles();
        
        // === SETUP INPUT ===
        this.setupInput();
        
        // === SETUP TIMERS ===
        this.exchangeTimer = this.time.addEvent({
            delay: 1500, // Exchange every 1.5 seconds
            callback: this.simulateExchange,
            callbackScope: this,
            loop: true
        });
        
        this.roundTimerEvent = this.time.addEvent({
            delay: 1000,
            callback: this.updateRoundTimer,
            callbackScope: this,
            loop: true
        });
        
        // === COMMENTARY ===
        this.addCommentary(`ROUND ${this.currentRound}! ${this.fighter1.name} vs ${this.fighter2.name}!`);
    }
    
    /**
     * Create pseudo-3D ring background (enhanced per fight mode graphics spec)
     * Spec: resolution 640x448, canvas #2a4a6b, diagonal grid, dynamic textures
     */
    createRingBackground() {
        const g = this.add.graphics();
        this.ringGraphics = g;
        
        // Store reference for dynamic blood decal layer
        this.bloodDecalGraphics = this.add.graphics();
        this.bloodDecalGraphics.setDepth(1);
        
        // Crowd background with multi-layer parallax effect (per spec: 3 tiers)
        for (let i = 0; i < 40; i++) {
            const y = 40 + i * 2.5;
            const brightness = 0.08 + (i / 40) * 0.15;
            const color = Phaser.Display.Color.GetColor(
                Math.floor(10 * brightness),
                Math.floor(10 * brightness),
                Math.floor(20 * brightness)
            );
            g.fillStyle(color);
            g.fillRect(0, y, 640, 3);
        }
        
        // Crowd heads with 3 tier silhouettes (per spec)
        const crowdColors = [0x0a0a0a, 0x1a1a1a, 0x2a2a2a];
        for (let x = 8; x < 632; x += 20) {
            for (let row = 0; row < 3; row++) {
                const y = 50 + row * 28 + Math.random() * 8;
                const shade = crowdColors[row];
                g.fillStyle(shade);
                g.fillCircle(x + Math.random() * 12, y, 6 + Math.random() * 3);
                
                // Arm silhouettes (per spec: cheer cycle)
                if (Math.random() > 0.7) {
                    g.fillRect(x + Math.random() * 8, y - 8, 2, 6);
                }
            }
        }
        
        // Ring mat (canvas floor) - per spec: #2a4a6b base with diagonal grid
        g.fillStyle(0x2a4a6b);
        g.beginPath();
        g.moveTo(80, 200);
        g.lineTo(560, 200);
        g.lineTo(600, 360);
        g.lineTo(40, 360);
        g.closePath();
        g.fillPath();
        
        // Canvas diagonal grid pattern (per spec)
        g.lineStyle(1, 0x3a5a7b, 0.3);
        for (let i = 0; i < 20; i++) {
            const x1 = 40 + i * 30;
            const x2 = 80 + i * 30;
            g.lineBetween(x1, 360, x2, 200);
            g.lineBetween(640 - x1, 360, 640 - x2, 200);
        }
        
        // Ring logo at center (per spec)
        g.lineStyle(2, 0x4a7a9b, 0.6);
        g.strokeCircle(320, 280, 40);
        g.lineStyle(1, 0x4a7a9b, 0.4);
        g.strokeCircle(320, 280, 50);
        
        // Ring center line
        g.lineStyle(2, 0x4a7a9b, 0.5);
        g.lineBetween(80, 280, 560, 280);
        
        // Ring posts with metallic gradient (per spec: 12x120 pixels)
        const posts = [
            { x: 80, y: 200, bottom: 310 },
            { x: 560, y: 200, bottom: 310 },
            { x: 40, y: 310, bottom: 360 },
            { x: 600, y: 310, bottom: 360 }
        ];
        
        posts.forEach(post => {
            // Post with metallic gradient
            g.fillStyle(0x888888);
            g.fillRect(post.x - 5, post.y - 60, 10, post.bottom - post.y + 60);
            // Highlight strip
            g.fillStyle(0xaaaaaa);
            g.fillRect(post.x - 2, post.y - 60, 3, post.bottom - post.y + 60);
            // Post top cap
            g.fillStyle(0xcccccc);
            g.fillCircle(post.x, post.y - 60, 7);
            // Rope attachment rings (per spec)
            g.lineStyle(1, 0x666666);
            g.strokeCircle(post.x, post.y - 45, 3);
            g.strokeCircle(post.x, post.y - 30, 3);
            g.strokeCircle(post.x, post.y - 15, 3);
        });
        
        // Corner pads (per spec: 16x16 pixels with stitching)
        const cornerPadPositions = [
            { x: 80, y: 200 },
            { x: 560, y: 200 }
        ];
        cornerPadPositions.forEach(pos => {
            g.fillStyle(0x1a1a1a);
            g.fillRect(pos.x - 8, pos.y - 8, 16, 16);
            // Stitching detail
            g.lineStyle(1, 0x333333);
            g.lineBetween(pos.x - 6, pos.y - 6, pos.x + 6, pos.y + 6);
            g.lineBetween(pos.x + 6, pos.y - 6, pos.x - 6, pos.y + 6);
        });
        
        // Ring ropes with 3 colors (per spec: red, white, blue with inner highlight)
        const ropeColors = [0xcc3333, 0xffffff, 0x3333cc];
        const ropeHighlights = [0xff5555, 0xffffff, 0x5555ff];
        const ropeYOffsets = [-45, -30, -15];
        
        ropeYOffsets.forEach((yOff, i) => {
            // Main rope (4px thickness per spec)
            g.lineStyle(4, ropeColors[i]);
            // Front rope
            g.lineBetween(40, 310 + yOff, 600, 310 + yOff);
            // Inner highlight (1px per spec)
            g.lineStyle(1, ropeHighlights[i], 0.6);
            g.lineBetween(40, 309 + yOff, 600, 309 + yOff);
            
            // Side ropes (slightly thinner)
            g.lineStyle(3, ropeColors[i]);
            g.lineBetween(80, 200 + yOff, 40, 310 + yOff);
            g.lineBetween(560, 200 + yOff, 600, 310 + yOff);
            
            // Back ropes (faded)
            g.lineStyle(2, ropeColors[i], 0.4);
            g.lineBetween(80, 200 + yOff, 560, 200 + yOff);
        });
        
        // Ring apron with gradient (per spec: #1a2a3a to #0a1a2a)
        g.fillStyle(0x1a2a3a);
        g.beginPath();
        g.moveTo(30, 360);
        g.lineTo(610, 360);
        g.lineTo(640, 390);
        g.lineTo(0, 390);
        g.closePath();
        g.fillPath();
        
        // Apron skirt with crowd shadows (per spec)
        g.fillStyle(0x0a1a2a);
        g.fillRect(0, 385, 640, 20);
        
        // Flickering crowd shadow silhouettes on apron
        for (let x = 20; x < 620; x += 40) {
            g.fillStyle(0x050510);
            const shadowHeight = 8 + Math.random() * 6;
            g.fillRect(x, 360, 15, shadowHeight);
        }
    }
    
    /**
     * Create animated crowd layer with camera flashes (per spec)
     */
    createCrowdLayer() {
        this.crowdGraphics = this.add.graphics();
        this.crowdGraphics.setDepth(0);
        
        // Create camera flash emitter positions
        this.cameraFlashPositions = [];
        for (let i = 0; i < 15; i++) {
            this.cameraFlashPositions.push({
                x: 30 + Math.random() * 580,
                y: 50 + Math.random() * 60
            });
        }
        
        // Create photographers at ringside (per spec: bottom sides, 24x32 pixels)
        this.photographerGraphics = this.add.graphics();
        this.photographerGraphics.setDepth(5);
        
        // Left photographer
        this.drawPhotographer(50, 380);
        // Right photographer
        this.drawPhotographer(590, 380);
    }
    
    /**
     * Draw photographer sprite (per spec)
     */
    drawPhotographer(x, y) {
        const g = this.photographerGraphics;
        // Body silhouette
        g.fillStyle(0x1a1a1a);
        g.fillRect(x - 10, y - 25, 20, 25);
        // Head
        g.fillCircle(x, y - 30, 8);
        // Camera
        g.fillStyle(0x333333);
        g.fillRect(x - 8, y - 20, 16, 10);
        // Lens
        g.fillStyle(0x555555);
        g.fillCircle(x, y - 15, 4);
    }
    
    /**
     * Create referee sprite (per spec: 56x88 pixels)
     */
    createReferee() {
        this.refereeGraphics = this.add.graphics();
        this.refereeGraphics.setDepth(3);
        this.refereeX = 320;
        this.refereeY = 240;
        this.refereeState = 'watching';
        this.drawReferee();
    }
    
    /**
     * Draw referee sprite (per spec)
     */
    drawReferee() {
        const g = this.refereeGraphics;
        const x = this.refereeX;
        const y = this.refereeY;
        
        g.clear();
        
        // Scale factor for 56x88 base size
        const s = 0.6;
        
        // Legs
        g.fillStyle(0x000000);
        g.fillRect(x - 8 * s, y + 20 * s, 8 * s, 30 * s);
        g.fillRect(x + 2 * s, y + 20 * s, 8 * s, 30 * s);
        
        // Shoes
        g.fillStyle(0x333333);
        g.fillRect(x - 10 * s, y + 48 * s, 12 * s, 6 * s);
        g.fillRect(x, y + 48 * s, 12 * s, 6 * s);
        
        // Shirt (white with stripes per spec)
        g.fillStyle(0xffffff);
        g.fillRect(x - 12 * s, y - 20 * s, 24 * s, 42 * s);
        
        // Black stripes on shirt
        g.fillStyle(0x000000);
        for (let i = 0; i < 4; i++) {
            g.fillRect(x - 12 * s + i * 8 * s, y - 20 * s, 3 * s, 42 * s);
        }
        
        // Arms (behind back in watching state per spec)
        g.fillStyle(0xd4a574);
        if (this.refereeState === 'watching') {
            // Arms behind back
            g.fillRect(x - 16 * s, y - 10 * s, 6 * s, 20 * s);
            g.fillRect(x + 10 * s, y - 10 * s, 6 * s, 20 * s);
        } else if (this.refereeState === 'counting') {
            // Arm raised for count
            g.fillRect(x + 10 * s, y - 40 * s, 6 * s, 25 * s);
            g.fillRect(x - 16 * s, y - 10 * s, 6 * s, 20 * s);
        }
        
        // Head
        g.fillStyle(0xd4a574);
        g.fillRect(x - 8 * s, y - 40 * s, 16 * s, 20 * s);
        
        // Hair
        g.fillStyle(0x333333);
        g.fillRect(x - 8 * s, y - 44 * s, 16 * s, 6 * s);
        
        // Bow tie (per spec: red or blue)
        g.fillStyle(0xff0000);
        g.fillRect(x - 4 * s, y - 22 * s, 8 * s, 4 * s);
    }
    
    /**
     * Create HUD elements (enhanced per fight mode graphics spec)
     * Includes: round timer, fighter nameplates, momentum indicator, combo counter
     */
    createHUD() {
        const hudStyle = {
            fontFamily: '"Press Start 2P"',
            fontSize: '10px',
            color: '#ffffff'
        };
        
        // Round display above timer (per spec)
        this.roundText = this.add.text(320, 12, `ROUND ${this.currentRound}`, {
            ...hudStyle,
            fontSize: '12px',
            color: '#ffdd00'
        }).setOrigin(0.5);
        
        // Timer with LCD digital style (per spec: 80x20 pixels, top center)
        this.timerBg = this.add.rectangle(320, 32, 80, 20, 0x000000, 0.8);
        this.timerBg.setStrokeStyle(1, 0x444444);
        
        this.timerText = this.add.text(320, 32, this.formatTime(this.roundTimer), {
            ...hudStyle,
            fontSize: '12px',
            color: '#00ff88'
        }).setOrigin(0.5);
        
        // Momentum indicator (per spec: 200x12 pixels, below timer)
        this.momentumBg = this.add.rectangle(320, 52, 160, 8, 0xaaaaaa);
        this.momentumBg.setStrokeStyle(1, 0x333333);
        
        // Momentum needle marker
        this.momentumNeedle = this.add.rectangle(320, 52, 4, 12, 0xffdd00);
        
        // Fighter 1 HUD (left, adjusted for 640 width)
        this.createFighterHUD(1, 10, 65, this.fighter1);
        
        // Fighter 2 HUD (right, adjusted for 640 width)
        this.createFighterHUD(2, 450, 65, this.fighter2);
        
        // Combo counter containers (per spec: above attacking fighter)
        this.combo1Text = this.add.text(200, 200, '', {
            ...hudStyle,
            fontSize: '10px',
            color: '#ffffff'
        }).setOrigin(0.5).setVisible(false);
        
        this.combo2Text = this.add.text(440, 200, '', {
            ...hudStyle,
            fontSize: '10px',
            color: '#ffffff'
        }).setOrigin(0.5).setVisible(false);
        
        // Commentary box (adjusted for 640 width)
        this.commentaryBg = this.add.rectangle(320, 425, 600, 40, 0x000000, 0.8);
        this.commentaryBg.setStrokeStyle(2, 0x333333);
        
        this.commentaryText = this.add.text(25, 415, '', {
            ...hudStyle,
            fontSize: '7px',
            color: '#00ff88',
            wordWrap: { width: 590 }
        });
        
        // Pause indicator
        this.pauseText = this.add.text(320, 200, 'PAUSED', {
            ...hudStyle,
            fontSize: '20px',
            color: '#ffdd00'
        }).setOrigin(0.5).setVisible(false);
        
        // Damage numbers container array (per spec: floating values)
        this.damageNumbers = [];
    }
    
    /**
     * Create individual fighter HUD (per spec: 120x32 pixels nameplates)
     */
    createFighterHUD(playerNum, x, y, fighter) {
        const prefix = `hud${playerNum}`;
        const hudStyle = {
            fontFamily: '"Press Start 2P"',
            fontSize: '8px',
            color: '#ffffff'
        };
        
        // Background with corner assignment color (per spec: red/blue matching)
        const bg = this.add.rectangle(x + 90, y + 35, 180, 75, 0x000000, 0.85);
        bg.setStrokeStyle(2, playerNum === 1 ? 0xe94560 : 0x4da6ff);
        
        // Name with nationality flag position (per spec)
        this[`${prefix}Name`] = this.add.text(x + 8, y, fighter.name.substring(0, 14), {
            ...hudStyle,
            color: playerNum === 1 ? '#e94560' : '#4da6ff'
        });
        
        // Health bar (per spec: 100x8 pixels with gradient)
        this.add.text(x + 8, y + 18, 'HP', { ...hudStyle, fontSize: '6px' });
        this[`${prefix}HealthBg`] = this.add.rectangle(x + 100, y + 21, 120, 10, 0x333333);
        this[`${prefix}Health`] = this.add.rectangle(x + 40, y + 21, 120, 8, 0x00ff88).setOrigin(0, 0.5);
        
        // Critical health warning indicator (hidden by default)
        this[`${prefix}CriticalFlash`] = this.add.rectangle(x + 100, y + 21, 120, 10, 0xff0000, 0);
        
        // Stamina bar (per spec: 100x6 pixels)
        this.add.text(x + 8, y + 33, 'ST', { ...hudStyle, fontSize: '6px' });
        this[`${prefix}StaminaBg`] = this.add.rectangle(x + 100, y + 36, 120, 8, 0x333333);
        this[`${prefix}Stamina`] = this.add.rectangle(x + 40, y + 36, 120, 6, 0xffff00).setOrigin(0, 0.5);
        
        // Special meter (per spec: 100x4 pixels, gradient white to gold)
        this.add.text(x + 8, y + 48, 'SP', { ...hudStyle, fontSize: '6px' });
        this[`${prefix}SpecialBg`] = this.add.rectangle(x + 100, y + 51, 120, 6, 0x333333);
        this[`${prefix}Special`] = this.add.rectangle(x + 40, y + 51, 0, 4, 0xffdd00).setOrigin(0, 0.5);
        
        // Score and knockdowns
        this[`${prefix}Score`] = this.add.text(x + 8, y + 60, 'PTS: 0', {
            ...hudStyle,
            fontSize: '6px'
        });
        
        // Knockdown icons (per spec: KD icons for each knockdown)
        this[`${prefix}KD`] = this.add.text(x + 90, y + 60, 'KD: 0', {
            ...hudStyle,
            fontSize: '6px',
            color: '#e94560'
        });
    }
    
    /**
     * Create particle emitters (enhanced per spec)
     * Includes: sweat spray, blood effects, impact sparks
     */
    createParticles() {
        // Create particle textures
        const particleGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        // White particle for sweat/impact
        particleGraphics.fillStyle(0xffffff);
        particleGraphics.fillCircle(4, 4, 4);
        particleGraphics.generateTexture('particle', 8, 8);
        
        // Blood particle (per spec: 2x3 pixels, red variants)
        particleGraphics.clear();
        particleGraphics.fillStyle(0xcc0000);
        particleGraphics.fillRect(0, 0, 3, 4);
        particleGraphics.generateTexture('bloodParticle', 3, 4);
        
        // Sweat particle (per spec: 2x2 pixels, #aaccff)
        particleGraphics.clear();
        particleGraphics.fillStyle(0xaaccff);
        particleGraphics.fillCircle(2, 2, 2);
        particleGraphics.generateTexture('sweatParticle', 4, 4);
        
        // Impact spark (per spec: white with yellow/orange highlights)
        particleGraphics.clear();
        particleGraphics.fillStyle(0xffff00);
        particleGraphics.fillCircle(2, 2, 2);
        particleGraphics.generateTexture('sparkParticle', 4, 4);
        
        particleGraphics.destroy();
        
        // Sweat spray emitter (per spec: 6-12 particles, opposing punch direction)
        this.sweatParticles = this.add.particles(0, 0, 'sweatParticle', {
            speed: { min: 80, max: 180 },
            angle: { min: -60, max: 60 },
            scale: { start: 0.8, end: 0.2 },
            alpha: { start: 0.8, end: 0 },
            lifespan: { min: 300, max: 500 },
            gravityY: 200,
            emitting: false
        });
        this.sweatParticles.setDepth(10);
        
        // Blood spray emitter (per spec: 4-8 particles)
        this.bloodParticles = this.add.particles(0, 0, 'bloodParticle', {
            speed: { min: 60, max: 150 },
            angle: { min: -90, max: 90 },
            scale: { start: 1, end: 0.5 },
            alpha: { start: 1, end: 0.3 },
            lifespan: { min: 400, max: 600 },
            gravityY: 300,
            emitting: false
        });
        this.bloodParticles.setDepth(10);
        
        // Impact spark emitter (per spec: 8-10 particles, radial)
        this.sparkParticles = this.add.particles(0, 0, 'sparkParticle', {
            speed: { min: 100, max: 200 },
            angle: { min: 0, max: 360 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 200,
            emitting: false
        });
        this.sparkParticles.setDepth(10);
        
        // General hit particles
        this.hitParticles = this.add.particles(0, 0, 'particle', {
            speed: { min: 50, max: 150 },
            angle: { min: -180, max: 180 },
            scale: { start: 0.4, end: 0 },
            lifespan: 400,
            gravityY: 200,
            emitting: false
        });
        this.hitParticles.setDepth(10);
    }
    
    /**
     * Setup keyboard input
     */
    setupInput() {
        // Pause toggle
        this.input.keyboard.on('keydown-SPACE', () => {
            this.togglePause();
        });
        
        // Next round (for testing)
        this.input.keyboard.on('keydown-N', () => {
            if (!this.isFightOver) {
                this.endRound();
            }
        });
        
        // Restart
        this.input.keyboard.on('keydown-R', () => {
            this.scene.restart();
        });
        
        // Queue action for fighter 1 (example: Q for jab)
        this.input.keyboard.on('keydown-Q', () => {
            this.fighter1.queueAction({
                action: 'jab',
                target: 'head',
                intensity: 80
            });
            this.addCommentary('Corner calls for a jab!');
        });
    }
    
    /**
     * Toggle pause state
     */
    togglePause() {
        this.isPaused = !this.isPaused;
        this.pauseText.setVisible(this.isPaused);
        
        if (this.isPaused) {
            this.exchangeTimer.paused = true;
            this.roundTimerEvent.paused = true;
        } else {
            this.exchangeTimer.paused = false;
            this.roundTimerEvent.paused = false;
        }
    }
    
    /**
     * Main game update loop (enhanced per spec)
     */
    update(time, delta) {
        if (this.isPaused || this.isFightOver) return;
        
        // Store time for use in other methods
        this.gameTime = time;
        
        // Update fighter renderers
        this.renderer1.update(delta);
        this.renderer2.update(delta);
        
        // Update HUD
        this.updateHUD();
        
        // Update momentum indicator (per spec: slides based on recent exchanges)
        this.updateMomentumIndicator();
        
        // Update combo timers (per spec: decay after no hits)
        this.updateComboTimers(delta);
        
        // Update camera flash cooldowns (per spec: 3-5 per second)
        this.updateCameraFlashes(delta);
        
        // Update damage number animations
        this.updateDamageNumbers(delta);
        
        // Update timer warning effects (per spec: red under 30s, pulse under 10s)
        this.updateTimerWarnings();
    }
    
    /**
     * Update momentum indicator position (per spec)
     */
    updateMomentumIndicator() {
        // Momentum ranges from -100 (fighter2 advantage) to 100 (fighter1 advantage)
        // Needle position: center = 320, range = 80 pixels each direction
        const needleX = 320 + (this.momentum * 0.8);
        this.momentumNeedle.setX(needleX);
        
        // Color the needle based on advantage
        if (this.momentum > 30) {
            this.momentumNeedle.setFillStyle(0xe94560); // Fighter 1 color
        } else if (this.momentum < -30) {
            this.momentumNeedle.setFillStyle(0x4da6ff); // Fighter 2 color
        } else {
            this.momentumNeedle.setFillStyle(0xffdd00); // Neutral
        }
    }
    
    /**
     * Update combo timers and display (per spec)
     */
    updateComboTimers(delta) {
        // Decay combo timers
        if (this.comboTimer.fighter1 > 0) {
            this.comboTimer.fighter1 -= delta;
            if (this.comboTimer.fighter1 <= 0) {
                this.comboCount.fighter1 = 0;
                this.combo1Text.setVisible(false);
            }
        }
        if (this.comboTimer.fighter2 > 0) {
            this.comboTimer.fighter2 -= delta;
            if (this.comboTimer.fighter2 <= 0) {
                this.comboCount.fighter2 = 0;
                this.combo2Text.setVisible(false);
            }
        }
    }
    
    /**
     * Update camera flash effects (per spec: random positions, 3-5 per second)
     */
    updateCameraFlashes(delta) {
        // Random camera flash in crowd (per spec: 3-5 per second, frame-rate independent)
        if (Math.random() < (delta / 1000) * 3) {
            this.triggerCameraFlash();
        }
    }
    
    /**
     * Trigger a camera flash effect (per spec)
     */
    triggerCameraFlash() {
        const pos = this.cameraFlashPositions[Math.floor(Math.random() * this.cameraFlashPositions.length)];
        
        // Create flash effect
        const flash = this.add.circle(pos.x, pos.y, 6, 0xffffff);
        flash.setAlpha(0.9);
        flash.setDepth(2);
        
        // Fade out
        this.tweens.add({
            targets: flash,
            alpha: 0,
            scale: 2,
            duration: 150,
            onComplete: () => flash.destroy()
        });
    }
    
    /**
     * Update damage number animations (per spec: rise and fade)
     */
    updateDamageNumbers(delta) {
        // Use delta (ms) for frame-rateâ€“independent movement and fading
        const dt = delta / 1000; // convert to seconds
        const riseSpeed = 30;    // pixels per second (approx. 0.5 px/frame at 60 FPS)
        const fadeSpeed = 1.2;   // alpha per second (approx. 0.02/frame at 60 FPS)
        
        for (let i = this.damageNumbers.length - 1; i >= 0; i--) {
            const dmgNum = this.damageNumbers[i];
            dmgNum.y -= riseSpeed * dt;
            dmgNum.alpha -= fadeSpeed * dt;
            
            if (dmgNum.alpha <= 0) {
                dmgNum.destroy();
                this.damageNumbers.splice(i, 1);
            }
        }
    }
    
    /**
     * Update timer warning effects (per spec)
     */
    updateTimerWarnings() {
        if (this.roundTimer <= 30) {
            this.timerText.setColor('#ff0000');
            
            // Pulse effect under 10 seconds (per spec) - use gameTime for frame-rate independence
            if (this.roundTimer <= 10) {
                const pulse = Math.sin((this.gameTime || 0) * 0.01) * 0.3 + 0.7;
                this.timerText.setAlpha(pulse);
            }
        } else {
            this.timerText.setColor('#00ff88');
            this.timerText.setAlpha(1);
        }
    }
    
    /**
     * Show floating damage number (per spec)
     */
    showDamageNumber(x, y, damage, isCritical) {
        const color = isCritical ? '#ffff00' : (damage > 10 ? '#ff0000' : '#ffffff');
        const fontSize = isCritical ? '12px' : '10px';
        
        const dmgText = this.add.text(x + (Math.random() - 0.5) * 20, y, Math.floor(damage).toString(), {
            fontFamily: '"Press Start 2P"',
            fontSize: fontSize,
            color: color,
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5);
        dmgText.setDepth(15);
        
        this.damageNumbers.push(dmgText);
        
        // Scale pop effect for critical hits
        if (isCritical) {
            this.tweens.add({
                targets: dmgText,
                scaleX: 1.5,
                scaleY: 1.5,
                duration: 100,
                yoyo: true
            });
        }
    }
    
    /**
     * Update combo counter display (per spec)
     */
    updateComboDisplay(attackerNum, count) {
        const comboText = attackerNum === 1 ? this.combo1Text : this.combo2Text;
        
        if (count >= 2) {
            comboText.setText(`HIT x${count}`);
            comboText.setVisible(true);
            
            // Color based on count (per spec: white, red at 5+, gold at 10+)
            if (count >= 10) {
                comboText.setColor('#ffdd00');
            } else if (count >= 5) {
                comboText.setColor('#ff0000');
            } else {
                comboText.setColor('#ffffff');
            }
            
            // Scale pulse effect
            this.tweens.add({
                targets: comboText,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 80,
                yoyo: true
            });
        }
    }
    
    /**
     * Simulate a single exchange
     */
    simulateExchange() {
        if (this.isPaused || !this.isRoundActive || this.isFightOver) return;
        
        // Check if either fighter is down
        if (this.fighter1.isDown || this.fighter2.isDown) return;
        
        // Get actions from both fighters
        const action1 = this.fighter1.getNextAction();
        const action2 = this.fighter2.getNextAction();
        
        // Determine who acts first based on speed
        const speed1 = this.fighter1.speed + Math.random() * 20;
        const speed2 = this.fighter2.speed + Math.random() * 20;
        
        if (speed1 >= speed2) {
            this.executeAction(this.fighter1, this.fighter2, action1, this.renderer1, this.renderer2, 1);
            this.time.delayedCall(300, () => {
                if (!this.fighter2.isDown) {
                    this.executeAction(this.fighter2, this.fighter1, action2, this.renderer2, this.renderer1, 2);
                }
            });
        } else {
            this.executeAction(this.fighter2, this.fighter1, action2, this.renderer2, this.renderer1, 2);
            this.time.delayedCall(300, () => {
                if (!this.fighter1.isDown) {
                    this.executeAction(this.fighter1, this.fighter2, action1, this.renderer1, this.renderer2, 1);
                }
            });
        }
    }
    
    /**
     * Execute a single action (enhanced per fight mode graphics spec)
     */
    executeAction(attacker, defender, action, attackerRenderer, defenderRenderer, attackerNum) {
        attackerRenderer.setState(action.action);
        
        // Stamina cost
        const staminaCost = {
            jab: 3,
            hook: 8,
            uppercut: 12,
            block: 2
        };
        attacker.useStamina(staminaCost[action.action] || 0);
        
        // Check if attacker is blocking (not attacking)
        if (action.action === 'block') {
            this.addCommentary(`${attacker.name} covers up!`);
            // Reset combo on blocking
            const comboKey = attackerNum === 1 ? 'fighter1' : 'fighter2';
            this.comboCount[comboKey] = 0;
            return;
        }
        
        // Check dodge
        if (defender.attemptDodge()) {
            defenderRenderer.setState('idle');
            this.addCommentary(`${defender.name} slips the ${action.action}!`);
            // Reset attacker's combo on miss
            const comboKey = attackerNum === 1 ? 'fighter1' : 'fighter2';
            this.comboCount[comboKey] = 0;
            // Shift momentum toward defender (per spec)
            this.momentum += attackerNum === 1 ? -5 : 5;
            this.momentum = Math.max(-100, Math.min(100, this.momentum));
            return;
        }
        
        // Calculate and apply damage (reduced if defender is blocking)
        let damage = attacker.calculateDamage(action.action, action.intensity);
        let isBlocked = false;
        
        // Check if defender is in blocking state - reduce damage significantly
        if (defenderRenderer.state === 'block') {
            damage = Math.floor(damage * 0.3); // 70% damage reduction when blocking
            isBlocked = true;
            this.addCommentary(`${defender.name} blocks! Reduced damage!`);
            
            // Emit block sparks (per spec: glove-on-glove contact)
            this.emitBlockSparks(defenderRenderer.x, defenderRenderer.y - 30);
        }
        
        const result = defender.takeDamage(damage, action.target);
        
        // Determine if this is a heavy punch for hit-stop effect
        const isHeavyPunch = damage > FightScene.HEAVY_PUNCH_THRESHOLD || 
                            action.action === 'hook' || 
                            action.action === 'uppercut';
        
        // Visual feedback with 7-level damage system and hit-stop on heavy punches
        defenderRenderer.takeDamage(damage, isHeavyPunch);
        
        // Apply hit-stop to both fighters on heavy punches (SEGA character level feature)
        if (isHeavyPunch && !isBlocked) {
            // Use damage-based calculation for consistent hit-stop
            attackerRenderer.triggerHitStop(null, damage);
            defenderRenderer.triggerHitStop(null, damage);
        }
        
        // Update combo counter (per spec)
        const comboKey = attackerNum === 1 ? 'fighter1' : 'fighter2';
        if (!isBlocked && damage > 0) {
            this.comboCount[comboKey]++;
            this.comboTimer[comboKey] = 2000; // 2 second combo window
            this.updateComboDisplay(attackerNum, this.comboCount[comboKey]);
        }
        
        // Update momentum (per spec: slides based on exchanges)
        const momentumShift = Math.min(damage * 0.5, 15);
        this.momentum += attackerNum === 1 ? momentumShift : -momentumShift;
        this.momentum = Math.max(-100, Math.min(100, this.momentum));
        
        // Show floating damage number (per spec)
        const isCritical = damage > 15 || result === 'heavy';
        this.showDamageNumber(defenderRenderer.x, defenderRenderer.y - 50, damage, isCritical);
        
        if (result === 'knockdown') {
            defenderRenderer.setState('knockdown');
            this.triggerKnockdown(defender, attacker, attackerNum);
            
            // Trigger flashbulb storm on knockdown (per spec)
            this.triggerFlashbulbStorm();
            
            // Big momentum swing on knockdown
            this.momentum = attackerNum === 1 ? 80 : -80;
        } else if (defenderRenderer.state !== 'block') {
            defenderRenderer.setState('damaged');
            this.time.delayedCall(200, () => {
                defenderRenderer.setState('idle');
            });
        }
        
        // Enhanced particle effects based on damage (per spec)
        const particleX = defenderRenderer.x;
        const particleY = action.target === 'head' ? defenderRenderer.y - 40 : defenderRenderer.y;
        
        if (!isBlocked) {
            // Sweat spray (per spec: 6-12 particles on medium-heavy hits)
            if (damage >= 5) {
                this.emitSweatSpray(particleX, particleY, attackerNum === 1 ? 1 : -1);
            }
            
            // Blood spray on heavy hits or if fighter is already damaged (per spec)
            if (damage >= 12 || (defender.health < 50 && damage >= 8)) {
                this.emitBloodSpray(particleX, particleY - 10, attackerNum === 1 ? 1 : -1);
                
                // Add blood decal to canvas (per spec: persistent)
                this.addBloodDecal(particleX + (Math.random() - 0.5) * 40, 340);
            }
        }
        
        // Enhanced screen shake (per spec: scales with impact)
        this.triggerScreenShake(damage, isCritical);
        
        // Camera flash burst on big hits (per spec)
        if (damage >= 10) {
            this.triggerCameraFlash();
            this.triggerCameraFlash();
        }
        
        // Screen tint on critical hits (per spec)
        if (isCritical) {
            this.triggerCriticalHitEffect();
        }
        
        // Commentary
        const hitType = result === 'heavy' ? 'HARD ' : result === 'medium' ? 'solid ' : '';
        this.addCommentary(`${attacker.name} lands a ${hitType}${action.action} to the ${action.target}!`);
        
        // Score points
        attacker.roundScore += damage;
    }
    
    /**
     * Emit sweat spray particles (per spec)
     */
    emitSweatSpray(x, y, direction) {
        this.sweatParticles.setPosition(x, y);
        this.sweatParticles.setAngle({ min: direction > 0 ? 120 : 30, max: direction > 0 ? 180 : 90 });
        this.sweatParticles.explode(6 + Math.floor(Math.random() * 6));
    }
    
    /**
     * Emit blood spray particles (per spec)
     */
    emitBloodSpray(x, y, direction) {
        this.bloodParticles.setPosition(x, y);
        this.bloodParticles.setAngle({ min: direction > 0 ? 100 : 50, max: direction > 0 ? 160 : 110 });
        this.bloodParticles.explode(4 + Math.floor(Math.random() * 4));
    }
    
    /**
     * Emit block sparks (per spec: impact sparks on blocked punch)
     */
    emitBlockSparks(x, y) {
        this.sparkParticles.setPosition(x, y);
        this.sparkParticles.explode(8);
    }
    
    /**
     * Add blood decal to canvas (per spec: persistent, fade 20% per round)
     */
    addBloodDecal(x, y) {
        const decal = {
            x: x,
            y: y,
            size: 3 + Math.random() * 4,
            opacity: 0.7
        };
        this.bloodDecals.push(decal);
        
        // Draw decal
        this.bloodDecalGraphics.fillStyle(0x880000, decal.opacity);
        this.bloodDecalGraphics.fillCircle(decal.x, decal.y, decal.size);
    }
    
    /**
     * Trigger flashbulb storm (per spec: all cameras flash on knockdown)
     */
    triggerFlashbulbStorm() {
        this.cameraFlashPositions.forEach((pos, index) => {
            this.time.delayedCall(index * 30, () => {
                const flash = this.add.circle(pos.x, pos.y, 8, 0xffffff);
                flash.setAlpha(1);
                flash.setDepth(2);
                
                this.tweens.add({
                    targets: flash,
                    alpha: 0,
                    scale: 2.5,
                    duration: 200,
                    onComplete: () => flash.destroy()
                });
            });
        });
    }
    
    /**
     * Trigger critical hit screen effect (per spec: red tint, 20% opacity, 6 frames)
     */
    triggerCriticalHitEffect() {
        const overlay = this.add.rectangle(320, 224, 640, 448, 0xff0000, 0.2);
        overlay.setDepth(20);
        
        this.tweens.add({
            targets: overlay,
            alpha: 0,
            duration: 100,
            onComplete: () => overlay.destroy()
        });
    }
    
    /**
     * Handle knockdown (enhanced per fight mode graphics spec)
     */
    triggerKnockdown(downFighter, upFighter, upFighterNum) {
        this.isRoundActive = false;
        this.addCommentary(`${downFighter.name} IS DOWN! THE COUNT BEGINS!`);
        
        // Set referee to counting state (per spec)
        this.refereeState = 'counting';
        this.refereeX = upFighterNum === 1 ? 380 : 260; // Move to downed fighter
        this.drawReferee();
        
        // Knockdown announcement (per spec: center top, falling letters)
        const kdText = this.add.text(320, 160, 'KNOCKDOWN!', {
            fontFamily: '"Press Start 2P"',
            fontSize: '16px',
            color: '#ff0000',
            stroke: '#000000',
            strokeThickness: 3
        }).setOrigin(0.5).setDepth(25);
        
        this.tweens.add({
            targets: kdText,
            y: 180,
            alpha: 0,
            duration: 2000,
            onComplete: () => kdText.destroy()
        });
        
        // Big screen shake (per spec: 500ms, high intensity)
        this.cameras.main.shake(500, 0.025);
        
        // Knockdown screen tint (per spec: fade to 40% black then back)
        const kdOverlay = this.add.rectangle(320, 224, 640, 448, 0x000000, 0);
        kdOverlay.setDepth(19);
        
        this.tweens.add({
            targets: kdOverlay,
            alpha: 0.4,
            duration: 300,
            yoyo: true,
            hold: 500,
            onComplete: () => kdOverlay.destroy()
        });
        
        // Count animation
        let count = 1;
        const countEvent = this.time.addEvent({
            delay: 1000,
            callback: () => {
                // Show count number on screen (per spec: referee counts with fingers)
                const countText = this.add.text(320, 200, count.toString(), {
                    fontFamily: '"Press Start 2P"',
                    fontSize: '24px',
                    color: '#ffdd00',
                    stroke: '#000000',
                    strokeThickness: 2
                }).setOrigin(0.5).setDepth(25);
                
                this.tweens.add({
                    targets: countText,
                    scale: 1.5,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => countText.destroy()
                });
                
                this.addCommentary(`...${count}!`);
                
                // Recovery check at count 8 - fighters typically must beat the 8 count
                // Recovery chance based on heart stat, decreases as count goes up
                const recoveryChance = (downFighter.heart / 100) * (1 - (count / 10));
                
                if (count >= 10) {
                    // KO
                    this.endFight(upFighterNum, 'KO');
                    countEvent.remove();
                    this.refereeState = 'watching';
                } else if (count === 8 && Math.random() < recoveryChance) {
                    // Fighter gets up at count 8 (standard boxing rule)
                    downFighter.isDown = false;
                    // Give fighter minimum viable health to continue
                    if (downFighter.health <= 20) {
                        downFighter.health = 20;
                    } else {
                        downFighter.health = Math.min(100, downFighter.health + 10);
                    }
                    this.addCommentary(`${downFighter.name} beats the count at 8!`);
                    this.isRoundActive = true;
                    countEvent.remove();
                    
                    // Reset referee position
                    this.refereeState = 'watching';
                    this.refereeX = 320;
                    this.drawReferee();
                    
                    // Reset renderer state
                    if (upFighterNum === 1) {
                        this.renderer2.setState('idle');
                    } else {
                        this.renderer1.setState('idle');
                    }
                }
                
                count++;
            },
            loop: true
        });
    }
    
    /**
     * Emit hit particles
     */
    emitHitParticles(x, y) {
        this.hitParticles.setPosition(x, y);
        this.hitParticles.explode(10);
    }
    
    /**
     * Trigger screen shake based on damage (enhanced per SEGA character level spec)
     * Per spec: magnitude 4-12 pixels, duration 8-20 frames, synchronized with hit-stop
     */
    triggerScreenShake(damage, isCritical = false) {
        // Base intensity scales with damage (per spec: 4-12 pixels)
        let intensity = Math.min(
            damage / FightScene.SHAKE_INTENSITY_DIVISOR, 
            FightScene.MAX_SHAKE_INTENSITY
        );
        let duration = Math.min(
            damage * FightScene.SHAKE_DURATION_MULTIPLIER + FightScene.BASE_SHAKE_DURATION, 
            FightScene.MAX_SHAKE_DURATION
        );
        
        // Critical hits get extra shake (heavy punches per spec)
        if (isCritical) {
            intensity *= FightScene.CRITICAL_INTENSITY_MULTIPLIER;
            duration *= FightScene.CRITICAL_DURATION_MULTIPLIER;
        }
        
        // Enhanced shake for heavy punches (2-4 frame hit-stop coordination)
        else if (damage > FightScene.HEAVY_PUNCH_THRESHOLD) {
            intensity *= FightScene.HEAVY_PUNCH_INTENSITY_MULTIPLIER;
        }
        
        this.cameras.main.shake(duration, intensity);
    }
    
    /**
     * Update round timer
     */
    updateRoundTimer() {
        if (!this.isRoundActive || this.isPaused) return;
        
        this.roundTimer--;
        this.timerText.setText(this.formatTime(this.roundTimer));
        
        if (this.roundTimer <= 0) {
            this.endRound();
        }
    }
    
    /**
     * End current round
     */
    endRound() {
        this.isRoundActive = false;
        
        // Score the round (10-point must system)
        const diff = this.fighter1.roundScore - this.fighter2.roundScore;
        let score1;
        let score2;

        if (diff === 0) {
            // Even round: both fighters get 10
            score1 = 10;
            score2 = 10;
        } else {
            // Translate damage difference into a point margin for the loser (1â€“4 points)
            const marginPoints = Math.min(4, Math.max(1, Math.floor(Math.abs(diff) / 20)));
            
            if (diff > 0) {
                // Fighter 1 wins the round
                score1 = 10;
                score2 = 10 - marginPoints;
            } else {
                // Fighter 2 wins the round
                score1 = 10 - marginPoints;
                score2 = 10;
            }
        }

        // Defensive clamp to keep scores within 6â€“10
        const finalScore1 = Math.max(6, Math.min(10, score1));
        const finalScore2 = Math.max(6, Math.min(10, score2));
        
        this.scores.fighter1.push(finalScore1);
        this.scores.fighter2.push(finalScore2);
        
        this.addCommentary(`END OF ROUND ${this.currentRound}! Scores: ${this.fighter1.name} ${finalScore1} - ${this.fighter2.name} ${finalScore2}`);
        
        if (this.currentRound >= this.maxRounds) {
            // Fight over - go to decision
            const total1 = this.scores.fighter1.reduce((a, b) => a + b, 0);
            const total2 = this.scores.fighter2.reduce((a, b) => a + b, 0);
            
            if (total1 > total2) {
                this.endFight(1, 'Decision');
            } else if (total2 > total1) {
                this.endFight(2, 'Decision');
            } else {
                this.endFight(0, 'Draw');
            }
        } else {
            // Corner break
            this.showCornerBreak();
        }
    }
    
    /**
     * Show corner break (between rounds)
     */
    showCornerBreak() {
        this.addCommentary('CORNER BREAK - Fighters recover...');
        
        // Recover fighters
        this.fighter1.recoverStamina(30);
        this.fighter2.recoverStamina(30);
        this.fighter1.resetRound();
        this.fighter2.resetRound();
        
        // Start next round after delay
        this.time.delayedCall(3000, () => {
            this.currentRound++;
            this.roundTimer = this.roundTime;
            this.roundText.setText(`ROUND ${this.currentRound}`);
            this.isRoundActive = true;
            this.addCommentary(`ROUND ${this.currentRound} BEGINS!`);
            
            // Fade blood decals by 20% per round (per spec)
            this.fadeBloodDecals();
        });
    }
    
    /**
     * Fade blood decals (per spec: 20% per round)
     */
    fadeBloodDecals() {
        this.bloodDecalGraphics.clear();
        this.bloodDecals.forEach(decal => {
            decal.opacity *= 0.8;
            if (decal.opacity > 0.1) {
                this.bloodDecalGraphics.fillStyle(0x880000, decal.opacity);
                this.bloodDecalGraphics.fillCircle(decal.x, decal.y, decal.size);
            }
        });
        // Remove very faded decals
        this.bloodDecals = this.bloodDecals.filter(d => d.opacity > 0.1);
    }
    
    /**
     * End the fight (enhanced per fight mode graphics spec)
     */
    endFight(winner, method) {
        this.isFightOver = true;
        this.exchangeTimer.remove();
        this.roundTimerEvent.remove();
        
        let winnerName;
        if (winner === 0) {
            winnerName = 'DRAW';
            this.addCommentary(`IT'S A DRAW!`);
        } else {
            winnerName = winner === 1 ? this.fighter1.name : this.fighter2.name;
            this.addCommentary(`${winnerName} WINS BY ${method}!`);
        }
        
        // Screen flash on KO (per spec)
        if (method === 'KO') {
            const flashOverlay = this.add.rectangle(320, 224, 640, 448, 0xffffff, 0.8);
            flashOverlay.setDepth(30);
            this.tweens.add({
                targets: flashOverlay,
                alpha: 0,
                duration: 300,
                onComplete: () => flashOverlay.destroy()
            });
        }
        
        // Show result overlay (adjusted for 640x448)
        const overlay = this.add.rectangle(320, 200, 480, 180, 0x000000, 0.9);
        overlay.setStrokeStyle(4, 0xffdd00);
        overlay.setDepth(25);
        
        // Fight result text (per spec: explosive entrance, 32pt font)
        const resultText = this.add.text(320, 160, 'FIGHT OVER', {
            fontFamily: '"Press Start 2P"',
            fontSize: '18px',
            color: '#e94560'
        }).setOrigin(0.5).setDepth(26);
        
        // Winner announcement (per spec: with animated outline)
        const winnerText = this.add.text(320, 200, winner === 0 ? 'DRAW!' : `${winnerName} WINS!`, {
            fontFamily: '"Press Start 2P"',
            fontSize: '14px',
            color: '#00ff88',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0.5).setDepth(26);
        
        // Method subtext
        this.add.text(320, 235, `by ${method}`, {
            fontFamily: '"Press Start 2P"',
            fontSize: '10px',
            color: '#ffdd00'
        }).setOrigin(0.5).setDepth(26);
        
        this.add.text(320, 270, 'Press R to restart', {
            fontFamily: '"Press Start 2P"',
            fontSize: '8px',
            color: '#888888'
        }).setOrigin(0.5).setDepth(26);
        
        // Pulse effect on winner text
        this.tweens.add({
            targets: winnerText,
            scaleX: 1.1,
            scaleY: 1.1,
            duration: 500,
            yoyo: true,
            repeat: -1
        });
    }
    
    /**
     * Update HUD displays (enhanced per spec)
     */
    updateHUD() {
        // Fighter 1
        const health1Pct = this.fighter1.health / this.fighter1.maxHealth;
        const stamina1Pct = this.fighter1.stamina / this.fighter1.maxStamina;
        this.hud1Health.setScale(health1Pct, 1);
        this.hud1Stamina.setScale(stamina1Pct, 1);
        this.hud1Score.setText(`PTS: ${Math.floor(this.fighter1.roundScore)}`);
        this.hud1KD.setText(`KD: ${this.fighter1.knockdowns}`);
        
        // Special meter (increases with damage dealt)
        const special1Pct = Math.min(this.fighter1.roundScore / 100, 1);
        this.hud1Special.setScale(special1Pct, 1);
        
        // Health bar gradient color (per spec: green to yellow to red)
        if (health1Pct < 0.2) {
            this.hud1Health.setFillStyle(0xff0000);
            // Critical health warning pulse (per spec) - use gameTime for frame-rate independence
            const pulse = Math.sin((this.gameTime || 0) * 0.01) * 0.3 + 0.3;
            this.hud1CriticalFlash.setAlpha(pulse);
        } else if (health1Pct < 0.5) {
            this.hud1Health.setFillStyle(0xffaa00);
            this.hud1CriticalFlash.setAlpha(0);
        } else {
            this.hud1Health.setFillStyle(0x00ff88);
            this.hud1CriticalFlash.setAlpha(0);
        }
        
        // Fighter 2
        const health2Pct = this.fighter2.health / this.fighter2.maxHealth;
        const stamina2Pct = this.fighter2.stamina / this.fighter2.maxStamina;
        this.hud2Health.setScale(health2Pct, 1);
        this.hud2Stamina.setScale(stamina2Pct, 1);
        this.hud2Score.setText(`PTS: ${Math.floor(this.fighter2.roundScore)}`);
        this.hud2KD.setText(`KD: ${this.fighter2.knockdowns}`);
        
        // Special meter
        const special2Pct = Math.min(this.fighter2.roundScore / 100, 1);
        this.hud2Special.setScale(special2Pct, 1);
        
        if (health2Pct < 0.2) {
            this.hud2Health.setFillStyle(0xff0000);
            const pulse = Math.sin((this.gameTime || 0) * 0.01) * 0.3 + 0.3;
            this.hud2CriticalFlash.setAlpha(pulse);
        } else if (health2Pct < 0.5) {
            this.hud2Health.setFillStyle(0xffaa00);
            this.hud2CriticalFlash.setAlpha(0);
        } else {
            this.hud2Health.setFillStyle(0x00ff88);
            this.hud2CriticalFlash.setAlpha(0);
        }
    }
    
    /**
     * Add commentary text
     */
    addCommentary(text) {
        this.commentaryText.setText(text);
    }
    
    /**
     * Format time as M:SS
     */
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
}

// === PHASER GAME CONFIGURATION ===
// Updated per fight mode graphics spec: 640x448 resolution, 4:3 aspect ratio
const config = {
    type: Phaser.AUTO,
    width: 640,
    height: 448,
    parent: 'game-container',
    backgroundColor: '#0a0a15',
    pixelArt: true,
    scene: [FightScene],
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

// Initialize game
const game = new Phaser.Game(config);

// === INTEGRATION API ===
// Export for use with manager UI
window.BrotherhoodBoxing = {
    FighterRenderer,
    Fighter,
    FightScene,
    
    /**
     * Start a fight with custom fighter configurations
     * @param {Object} fighter1Config - Configuration for fighter 1
     * @param {Object} fighter2Config - Configuration for fighter 2
     */
    startFight: function(fighter1Config, fighter2Config) {
        // Basic validation
        if (!fighter1Config || typeof fighter1Config !== 'object') {
            console.warn('startFight: invalid fighter1Config');
            return;
        }
        if (!fighter2Config || typeof fighter2Config !== 'object') {
            console.warn('startFight: invalid fighter2Config');
            return;
        }
        game.scene.start('FightScene', { fighter1: fighter1Config, fighter2: fighter2Config });
    },
    
    /**
     * Queue a corner action for a fighter
     * @param {number} fighterNum - 1 or 2
     * @param {Object} action - {action: 'jab'|'hook'|'uppercut'|'block', target: 'head'|'body', intensity: 0-100}
     */
    queueCornerAction: function(fighterNum, action) {
        const validActions = ['jab', 'hook', 'uppercut', 'block'];
        const validTargets = ['head', 'body'];

        // Basic structure and bounds validation for the corner action
        if (!action || typeof action !== 'object') {
            console.warn('queueCornerAction: invalid action object', action);
            return;
        }

        const actionType = action.action;
        const target = action.target;
        const intensityNum = Number(action.intensity);

        if (!validActions.includes(actionType) ||
            !validTargets.includes(target) ||
            !Number.isFinite(intensityNum) ||
            intensityNum < 0 ||
            intensityNum > 100) {
            console.warn('queueCornerAction: action failed validation', action);
            return;
        }

        const scene = game.scene.getScene('FightScene');
        if (scene) {
            const fighter = fighterNum === 1 ? scene.fighter1 : scene.fighter2;
            // Pass a normalized action object to the fighter
            fighter.queueAction({
                action: actionType,
                target: target,
                intensity: intensityNum
            });
        }
    },
    
    /**
     * Set strategy for a fighter
     * @param {number} fighterNum - 1 or 2
     * @param {string} strategy - 'aggressive'|'defensive'|'balanced'|'body'|'head'
     */
    setStrategy: function(fighterNum, strategy) {
        const scene = game.scene.getScene('FightScene');
        if (scene) {
            const fighter = fighterNum === 1 ? scene.fighter1 : scene.fighter2;
            const allowedStrategies = ['aggressive', 'defensive', 'balanced', 'body', 'head'];
            if (allowedStrategies.includes(strategy)) {
                fighter.currentStrategy = strategy;
            } else {
                console.warn('Invalid strategy value passed to setStrategy:', strategy);
            }
        }
    },
    
    /**
     * Get current fight state
     */
    getFightState: function() {
        const scene = game.scene.getScene('FightScene');
        if (scene) {
            return {
                round: scene.currentRound,
                timer: scene.roundTimer,
                isPaused: scene.isPaused,
                isFightOver: scene.isFightOver,
                fighter1: {
                    name: scene.fighter1.name,
                    health: scene.fighter1.health,
                    stamina: scene.fighter1.stamina,
                    knockdowns: scene.fighter1.knockdowns,
                    score: scene.fighter1.roundScore
                },
                fighter2: {
                    name: scene.fighter2.name,
                    health: scene.fighter2.health,
                    stamina: scene.fighter2.stamina,
                    knockdowns: scene.fighter2.knockdowns,
                    score: scene.fighter2.roundScore
                }
            };
        }
        return null;
    }
};

// Example: Queue corner actions from manager UI
// window.BrotherhoodBoxing.queueCornerAction(1, {action: 'jab', target: 'head', intensity: 80});
// window.BrotherhoodBoxing.setStrategy(1, 'aggressive');
</script>
</body>
</html>
