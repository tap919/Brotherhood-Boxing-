<!DOCTYPE html>
<html>
<head>
    <title>Boxing Sim Fight Engine</title>
    <style>
        body { margin: 0; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: monospace; }
        canvas { border: 4px solid #fff; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font-size: 18px; }
    </style>
</head>
<body>
    <canvas id="ring" width="800" height="600"></canvas>
    <div id="ui">
        <div>Round: <span id="round">1</span> | Time: <span id="time">3:00</span></div>
        <div>Player Health: <span id="pHealth">100</span> | Stamina: <span id="pStam">100</span></div>
        <div>Opponent Health: <span id="oHealth">100</span> | Stamina: <span id="oStam">100</span></div>
    </div>
    <script>
        const canvas = document.getElementById('ring');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // Pixel art crispness[web:15]

        // Scale for retro feel (effective 320x240)
        const SCALE = 2;
        const VW = canvas.width / SCALE, VH = canvas.height / SCALE;

        class Boxer {
            constructor(x, color, facingRight = true) {
                this.x = x;
                this.y = VH * 0.6;
                this.color = color;
                this.facingRight = facingRight;
                this.health = 100;
                this.stamina = 100;
                this.state = 'idle'; // idle, jab, hook, block, hit, knockdown
                this.frame = 0;
                this.animSpeed = 0.2;
                this.vx = 0; // For stagger
            }

            update(actions) {
                if (this.state !== 'idle') {
                    this.frame += this.animSpeed;
                    if (this.frame > 8) {
                        this.state = 'idle';
                        this.frame = 0;
                    }
                }
                // Simulate actions (replace with your stats later)
                if (actions.length > 0) {
                    const action = actions.shift();
                    if (action.target === this) {
                        this.state = action.type;
                        this.frame = 0;
                        if (action.type === 'hit') this.health -= 10;
                        if (action.type === 'knockdown') {
                            this.state = 'knockdown';
                            setTimeout(() => { this.state = 'idle'; this.health -= 30; }, 2000);
                        }
                    }
                }
                this.x += this.vx * 0.1;
                this.vx *= 0.9; // Friction
                this.stamina = Math.max(0, this.stamina - 0.1);
            }

            draw() {
                ctx.save();
                ctx.scale(SCALE, SCALE);
                ctx.translate(this.x, this.y);

                if (!this.facingRight) {
                    ctx.scale(-1, 1);
                    ctx.translate(30, 0); // Flip offset
                }

                // Pixelated shading helper
                const shade = (r, g, b, s = 1) => `rgb(${r*s},${g*s},${b*s})`;

                // Legs (simple stance)
                ctx.fillStyle = shade(100, 50, 0);
                ctx.fillRect(-8, 20, 6, 12);
                ctx.fillRect(2, 20, 6, 12);

                // Torso
                ctx.fillStyle = shade(50, 20, 10);
                ctx.fillRect(-12, 0, 24, 20);

                // Head (Punch-Out style oversized)
                ctx.fillStyle = shade(240, 180, 140);
                ctx.fillRect(-10, -25, 20, 25);
                ctx.fillStyle = shade(200, 100, 80);
                ctx.fillRect(-8, -20, 16, 8); // Face

                // Arms - animated based on state/frame
                let armL_x = -18 + Math.sin(this.frame) * 5;
                let armR_x = 12 + Math.sin(this.frame + 2) * 3;
                let armL_y = 5 + Math.sin(this.frame * 2) * 2;
                let armR_y = 5;

                if (this.state === 'jab') {
                    armL_x = -25 + this.frame * 2;
                    armL_y = 3 - this.frame * 0.5;
                } else if (this.state === 'hook') {
                    armR_x = 20 + this.frame * 1.5;
                    armR_y = 10 - Math.cos(this.frame) * 3;
                } else if (this.state === 'block') {
                    armL_x = -15; armR_x = 5;
                    armL_y = -5; armR_y = -5;
                } else if (this.state === 'hit') {
                    armL_x += Math.sin(this.frame * 5) * 3;
                    armR_x += Math.sin(this.frame * 5 + 1) * 3;
                } else if (this.state === 'knockdown') {
                    ctx.translate(10, 10); // Fall back
                }

                // Left arm
                ctx.fillStyle = shade(80, 40, 20);
                ctx.fillRect(armL_x, armL_y, 8, 20);
                ctx.fillStyle = shade(120, 80, 60); // Glove
                ctx.beginPath();
                ctx.arc(armL_x + 8, armL_y + 10, 6, 0, Math.PI * 2);
                ctx.fill();

                // Right arm
                ctx.fillStyle = shade(80, 40, 20);
                ctx.fillRect(armR_x, armR_y, 8, 20);
                ctx.fillStyle = shade(120, 80, 60);
                ctx.beginPath();
                ctx.arc(armR_x + 8, armR_y + 10, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Game state
        let player = new Boxer(VW * 0.25, [200,100,100]);
        let opponent = new Boxer(VW * 0.7, [100,100,200], false);
        let round = 1;
        let timeLeft = 180; // 3 min
        let actions = []; // Queue: {target: boxer, type: 'jab'|'hook'|'block'|'hit'|'knockdown'}
        let paused = false;

        // Sample round sim (replace with your corner inputs/stats)
        function generateRoundActions() {
            actions = [];
            // Player jab -> opponent block -> opponent hook hits player
            actions.push({target: opponent, type: 'jab'});
            actions.push({target: opponent, type: 'block'});
            actions.push({target: player, type: 'hook'});
            actions.push({target: player, type: 'hit'});
        }

        function drawRing() {
            ctx.save();
            ctx.scale(SCALE, SCALE);

            // Floor
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, VH * 0.5, VW, VH * 0.5);

            // Ropes
            ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(VW * 0.1, VH * 0.55); ctx.lineTo(VW * 0.9, VH * 0.55);
            ctx.moveTo(VW * 0.1, VH * 0.65); ctx.lineTo(VW * 0.9, VH * 0.65);
            ctx.stroke();

            // Corners
            ctx.fillStyle = '#654321';
            ctx.fillRect(0, VH * 0.5, 40, 80);
            ctx.fillRect(VW - 40, VH * 0.5, 40, 80);

            // Crowd (pixels)
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `hsl(${Math.random()*60 + 200}, 50%, ${40 + Math.random()*20}%)`;
                ctx.fillRect(Math.random() * VW, Math.random() * (VH * 0.5), 2, 2);
            }

            // Referee (simple)
            ctx.fillStyle = '#000';
            ctx.fillRect(VW * 0.48, VH * 0.55, 4, 20);

            ctx.restore();
        }

        function updateUI() {
            document.getElementById('round').textContent = round;
            document.getElementById('time').textContent = `${Math.floor(timeLeft/60)}:${(timeLeft%60).toString().padStart(2,'0')}`;
            document.getElementById('pHealth').textContent = Math.max(0, player.health);
            document.getElementById('pStam').textContent = Math.max(0, player.stamina);
            document.getElementById('oHealth').textContent = Math.max(0, opponent.health);
            document.getElementById('oStam').textContent = Math.max(0, opponent.stamina);
        }

        function animate() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawRing();
            player.update(actions);
            opponent.update(actions);
            player.draw();
            opponent.draw();

            // Health bars
            ctx.fillStyle = '#f00';
            ctx.fillRect(10, 10, player.health * 2, 20);
            ctx.fillRect(canvas.width - 210, 10, opponent.health * 2, 20);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(10, 10, 200, 20);
            ctx.strokeRect(canvas.width - 210, 10, 200, 20);

            timeLeft -= 1/60;
            if (timeLeft <= 0 || actions.length === 0) {
                round++;
                timeLeft = 180;
                generateRoundActions(); // Next round
            }

            updateUI();
            requestAnimationFrame(animate);[web:15]
        }

        // Start
        generateRoundActions();
        animate();
    </script>
</body>
</html>
