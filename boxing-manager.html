<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brotherhood Boxing - Two Player Manager Sim</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; image-rendering: pixelated; }
        body {
            font-family: 'Press Start 2P', cursive;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            overflow-x: hidden;
        }
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 3px);
            z-index: 9999;
        }
        .game-wrapper { max-width: 1000px; margin: 0 auto; padding: 10px; }
        .game-header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #e94560;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.3);
        }
        .game-title {
            font-size: 20px;
            color: #e94560;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #ff6b8a;
            letter-spacing: 2px;
            animation: titlePulse 2s infinite;
        }
        @keyframes titlePulse {
            0%, 100% { text-shadow: 3px 3px 0 #000, 0 0 10px #e94560; }
            50% { text-shadow: 3px 3px 0 #000, 0 0 20px #ff6b8a; }
        }
        .game-subtitle { font-size: 8px; color: #00ff88; margin-top: 8px; letter-spacing: 4px; }
        .screen { display: none; }
        .screen.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .panel {
            background: linear-gradient(135deg, #1f4068 0%, #162447 100%);
            border: 3px solid #e94560;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
        }
        .panel.blue { border-color: #4da6ff; }
        .panel.green { border-color: #00ff88; }
        .panel.gold { border-color: #ffdd00; }
        .btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            padding: 12px 16px;
            background: linear-gradient(180deg, #e94560 0%, #b83250 100%);
            color: white;
            border: 3px solid #fff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s;
            margin: 4px;
            text-shadow: 1px 1px 0 #000;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(233, 69, 96, 0.5); }
        .btn:active { transform: scale(0.95); }
        .btn.blue { background: linear-gradient(180deg, #4da6ff 0%, #0066cc 100%); }
        .btn.green { background: linear-gradient(180deg, #00ff88 0%, #00aa55 100%); color: #000; text-shadow: none; }
        .btn.gold { background: linear-gradient(180deg, #ffdd00 0%, #cc9900 100%); color: #000; text-shadow: none; }
        .btn.large { font-size: 11px; padding: 18px 30px; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .menu-container { display: flex; flex-direction: column; align-items: center; gap: 15px; padding: 40px 20px; }
        .menu-btn { width: 280px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .title { font-size: 12px; color: #ffdd00; text-align: center; margin-bottom: 15px; }
        .subtitle { font-size: 9px; color: #00ff88; margin-bottom: 10px; }
        .label { font-size: 8px; color: #888; }
        .value { font-size: 10px; color: #fff; }
        .highlight { color: #ffdd00; }
        .success { color: #00ff88; }
        .danger { color: #e94560; }
        .input {
            width: 100%;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            background: #0a0a15;
            color: #fff;
            border: 2px solid #555;
            border-radius: 4px;
        }
        .input:focus { border-color: #e94560; outline: none; }
        .fighter-card {
            background: linear-gradient(135deg, #1a2a4a 0%, #0f1a2e 100%);
            border: 3px solid #555;
            border-radius: 4px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .fighter-card:hover { border-color: #e94560; transform: translateY(-2px); }
        .fighter-card.selected { border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.4); }
        .fighter-sprite {
            width: 48px;
            height: 64px;
            margin: 0 auto 8px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .fighter-name { font-size: 9px; color: #ffdd00; text-align: center; margin-bottom: 6px; }
        .stat-row { display: flex; justify-content: space-between; align-items: center; font-size: 7px; margin: 3px 0; }
        .stat-bar { width: 50px; height: 6px; background: #222; border: 1px solid #444; border-radius: 2px; overflow: hidden; }
        .stat-fill { height: 100%; background: linear-gradient(90deg, #e94560, #ff6b8a); transition: width 0.3s; }
        .stat-fill.blue { background: linear-gradient(90deg, #4da6ff, #66b3ff); }
        .stat-fill.green { background: linear-gradient(90deg, #00ff88, #66ffaa); }
        .ring-container {
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 100%);
            border: 6px solid #8B4513;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .ring-canvas {
            width: 100%;
            height: 300px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 4px solid #ffdd00;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .ring-floor {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 60px;
            background: linear-gradient(180deg, #8B7355 0%, #6B5344 100%);
            border-top: 3px solid #A08060;
        }
        .ring-rope {
            position: absolute;
            left: 5%; right: 5%;
            height: 3px;
            background: linear-gradient(90deg, #e94560, #ff6b8a, #e94560);
            box-shadow: 0 0 5px #e94560;
        }
        .rope-1 { top: 25%; }
        .rope-2 { top: 40%; }
        .rope-3 { top: 55%; }
        .ring-fighter {
            position: absolute;
            bottom: 80px;
            width: 60px;
            height: 90px;
            transition: all 0.3s;
        }
        .ring-fighter.left { left: 25%; }
        .ring-fighter.right { right: 25%; }
        .pixel-boxer { width: 40px; height: 70px; position: relative; margin: 0 auto; }
        .boxer-head {
            width: 24px; height: 24px;
            background: #daa520;
            border: 2px solid #8B4513;
            border-radius: 4px;
            position: absolute;
            top: 0; left: 50%;
            transform: translateX(-50%);
        }
        .boxer-body {
            width: 28px; height: 24px;
            position: absolute;
            top: 22px; left: 50%;
            transform: translateX(-50%);
            border: 2px solid;
            border-radius: 2px;
        }
        .boxer-body.red { background: #e94560; border-color: #b83250; }
        .boxer-body.blue { background: #4da6ff; border-color: #0066cc; }
        .boxer-glove {
            width: 12px; height: 12px;
            border-radius: 50%;
            position: absolute;
            top: 28px;
            border: 2px solid;
        }
        .boxer-glove.left-glove { left: -2px; }
        .boxer-glove.right-glove { right: -2px; }
        .boxer-glove.red { background: #ff0000; border-color: #990000; }
        .boxer-glove.blue { background: #0066cc; border-color: #003366; }
        .boxer-shorts {
            width: 24px; height: 14px;
            position: absolute;
            top: 44px; left: 50%;
            transform: translateX(-50%);
            border: 2px solid;
            border-radius: 2px;
        }
        .boxer-shorts.red { background: #ffdd00; border-color: #cc9900; }
        .boxer-shorts.blue { background: #00ff88; border-color: #00aa55; }
        .boxer-legs {
            position: absolute;
            top: 56px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
        }
        .boxer-leg { width: 8px; height: 16px; background: #daa520; border: 2px solid #8B4513; }
        .fighter-hud {
            position: absolute;
            width: 120px;
            padding: 5px;
            background: rgba(0,0,0,0.85);
            border: 2px solid #555;
            border-radius: 4px;
            top: 10px;
        }
        .fighter-hud.left { left: 10px; }
        .fighter-hud.right { right: 10px; }
        .hud-name { font-size: 7px; color: #ffdd00; margin-bottom: 4px; }
        .hud-bar {
            height: 10px;
            background: #222;
            border: 1px solid #444;
            margin-bottom: 3px;
            border-radius: 2px;
            overflow: hidden;
        }
        .hud-fill { height: 100%; transition: width 0.5s; }
        .hud-fill.health { background: linear-gradient(90deg, #00ff88, #00cc66); }
        .hud-fill.health.low { background: linear-gradient(90deg, #ff6b6b, #cc0000); }
        .hud-fill.stamina { background: linear-gradient(90deg, #4da6ff, #0066cc); }
        .round-display {
            text-align: center;
            padding: 12px;
            background: #000;
            border: 3px solid #ffdd00;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .round-num { font-size: 16px; color: #ffdd00; }
        .round-timer { font-size: 12px; color: #00ff88; margin-top: 5px; }
        .commentary {
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin: 10px 0;
            max-height: 120px;
            overflow-y: auto;
        }
        .commentary p { font-size: 8px; line-height: 1.6; margin: 4px 0; }
        .commentary .action { color: #00ff88; }
        .commentary .hit { color: #e94560; }
        .commentary .info { color: #4da6ff; }
        .corner-stat { display: flex; justify-content: space-between; font-size: 8px; padding: 5px 0; border-bottom: 1px solid #333; }
        .corner-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 10px 0; }
        .corner-btn { font-size: 7px; padding: 10px 8px; }
        .strategy-btn { padding: 12px 8px; font-size: 7px; text-align: center; }
        .strategy-btn.selected { background: linear-gradient(180deg, #00ff88 0%, #00aa55 100%); color: #000; text-shadow: none; }
        .result-banner {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #1f4068 0%, #162447 100%);
            border: 4px solid #ffdd00;
            border-radius: 8px;
            margin: 20px 0;
        }
        .result-title { font-size: 18px; color: #ffdd00; text-shadow: 3px 3px 0 #000; margin-bottom: 15px; }
        .result-winner { font-size: 14px; color: #00ff88; margin: 15px 0; }
        .result-method { font-size: 10px; color: #e94560; }
        .scorecard { background: #000; border: 2px solid #ffdd00; padding: 15px; margin: 15px 0; }
        .scorecard-row { display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; font-size: 9px; padding: 4px 0; }
        .score-left { text-align: left; color: #e94560; }
        .score-center { text-align: center; color: #888; }
        .score-right { text-align: right; color: #4da6ff; }
        @keyframes punch { 0% { transform: translateX(0); } 50% { transform: translateX(20px); } 100% { transform: translateX(0); } }
        @keyframes punchRight { 0% { transform: translateX(0); } 50% { transform: translateX(-20px); } 100% { transform: translateX(0); } }
        @keyframes hit { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(2) hue-rotate(180deg); } }
        @keyframes screenShake { 
            0%, 100% { transform: translateX(0); } 
            10% { transform: translateX(-5px) translateY(-3px); } 
            20% { transform: translateX(5px) translateY(2px); } 
            30% { transform: translateX(-4px) translateY(-2px); } 
            40% { transform: translateX(4px) translateY(3px); } 
            50% { transform: translateX(-3px) translateY(-1px); } 
            60% { transform: translateX(3px) translateY(1px); } 
            70% { transform: translateX(-2px); } 
            80% { transform: translateX(2px); } 
            90% { transform: translateX(-1px); } 
        }
        @keyframes knockdownFlash { 
            0% { background-color: rgba(255, 0, 0, 0.5); } 
            100% { background-color: transparent; } 
        }
        @keyframes powerPunch { 
            0% { transform: translateX(0) scale(1); } 
            25% { transform: translateX(-10px) scale(1.1); } 
            50% { transform: translateX(30px) scale(1.15); } 
            100% { transform: translateX(0) scale(1); } 
        }
        @keyframes powerPunchRight { 
            0% { transform: translateX(0) scale(1); } 
            25% { transform: translateX(10px) scale(1.1); } 
            50% { transform: translateX(-30px) scale(1.15); } 
            100% { transform: translateX(0) scale(1); } 
        }
        @keyframes stagger { 
            0%, 100% { transform: translateX(0); } 
            25% { transform: translateX(-15px) rotate(-5deg); } 
            75% { transform: translateX(15px) rotate(5deg); } 
        }
        .punching { animation: punch 0.3s ease-out; }
        .punching-right { animation: punchRight 0.3s ease-out; }
        .power-punching { animation: powerPunch 0.4s ease-out; }
        .power-punching-right { animation: powerPunchRight 0.4s ease-out; }
        .hit-effect { animation: hit 0.2s; }
        .staggered { animation: stagger 0.6s ease-out; }
        .screen-shake { animation: screenShake 0.4s ease-out; }
        .knockdown-flash { animation: knockdownFlash 0.5s ease-out; }
        .momentum-indicator { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            margin: 5px 0; 
            padding: 5px; 
            background: rgba(0,0,0,0.5); 
            border-radius: 4px; 
        }
        .momentum-bar { 
            width: 200px; 
            height: 8px; 
            background: linear-gradient(90deg, #e94560 0%, #e94560 50%, #4da6ff 50%, #4da6ff 100%); 
            border-radius: 4px; 
            position: relative; 
            border: 1px solid #fff; 
        }
        .momentum-marker { 
            position: absolute; 
            top: -4px; 
            width: 4px; 
            height: 16px; 
            background: #ffdd00; 
            border-radius: 2px; 
            transition: left 0.3s ease; 
            box-shadow: 0 0 8px #ffdd00; 
        }
        .punch-stats { 
            display: flex; 
            justify-content: space-between; 
            font-size: 7px; 
            padding: 5px 10px; 
            background: rgba(0,0,0,0.7); 
            border-radius: 4px; 
            margin: 5px 0; 
        }
        .distance-indicator { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: 7px; 
            color: #888; 
            margin: 3px 0; 
        }
        .distance-close { color: #e94560; }
        .distance-mid { color: #ffdd00; }
        .distance-far { color: #4da6ff; }
        .divider { height: 4px; background: repeating-linear-gradient(90deg, #e94560 0px, #e94560 8px, transparent 8px, transparent 16px); margin: 15px 0; }
        .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-box { background: #16213e; border: 4px solid #e94560; border-radius: 8px; padding: 25px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-title { font-size: 14px; color: #ffdd00; margin-bottom: 15px; text-align: center; }
        .modal-text { font-size: 8px; color: #ccc; line-height: 1.8; }
        .turn-banner { text-align: center; padding: 12px; background: linear-gradient(180deg, #e94560 0%, #b83250 100%); border: 3px solid #ffdd00; border-radius: 4px; margin: 10px 0; font-size: 10px; }
        .injury-tag { display: inline-block; font-size: 6px; padding: 2px 4px; border-radius: 2px; margin: 1px; }
        .injury-tag.cut { background: #cc0000; color: white; }
        .injury-tag.swelling { background: #9932CC; color: white; }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="game-header">
            <h1 class="game-title">BROTHERHOOD BOXING</h1>
            <p class="game-subtitle">‚òÖ TWO PLAYER MANAGER SIM ‚òÖ</p>
        </div>
        
        <div id="menu-screen" class="screen active">
            <div class="menu-container">
                <div class="panel" style="text-align: center; max-width: 400px;">
                    <p style="font-size: 8px; color: #888; margin-bottom: 20px;">
                        Manage your boxing stable. Watch the fights.<br>Control the corner between rounds.
                    </p>
                </div>
                <button class="btn large menu-btn" onclick="startNewGame()">ü•ä NEW FRANCHISE</button>
                <button class="btn large menu-btn blue" onclick="loadGame()">üíæ CONTINUE</button>
                <button class="btn large menu-btn gold" onclick="showModal('rules-modal')">üìñ HOW TO PLAY</button>
            </div>
        </div>
        
        <div id="setup-screen" class="screen">
            <h2 class="title">FRANCHISE SETUP</h2>
            <div class="grid-2">
                <div class="panel">
                    <p class="subtitle">üî¥ PLAYER 1 - RED CORNER</p>
                    <input type="text" id="p1-name-input" class="input" placeholder="Enter manager name..." maxlength="12">
                    <p class="label" style="margin-top: 8px;">Starting Budget: <span class="success">$50,000</span></p>
                </div>
                <div class="panel blue">
                    <p class="subtitle" style="color: #4da6ff;">üîµ PLAYER 2 - BLUE CORNER</p>
                    <input type="text" id="p2-name-input" class="input" placeholder="Enter manager name..." maxlength="12">
                    <p class="label" style="margin-top: 8px;">Starting Budget: <span class="success">$50,000</span></p>
                </div>
            </div>
            <div class="divider"></div>
            <div style="text-align: center;">
                <button class="btn green large" onclick="confirmSetup()">START FRANCHISE</button>
                <button class="btn" onclick="showScreen('menu-screen')">BACK</button>
            </div>
        </div>
        
        <div id="hub-screen" class="screen">
            <div class="grid-2" style="margin-bottom: 10px;">
                <div class="panel" id="hub-p1-panel">
                    <p class="subtitle">üî¥ <span id="hub-p1-name">PLAYER 1</span></p>
                    <p class="value success" id="hub-p1-money">$50,000</p>
                    <p class="label">Record: <span id="hub-p1-record">0-0</span></p>
                </div>
                <div class="panel blue" id="hub-p2-panel">
                    <p class="subtitle" style="color: #4da6ff;">üîµ <span id="hub-p2-name">PLAYER 2</span></p>
                    <p class="value success" id="hub-p2-money">$50,000</p>
                    <p class="label">Record: <span id="hub-p2-record">0-0</span></p>
                </div>
            </div>
            <div class="round-display">
                <div class="round-num">SEASON <span id="hub-season">1</span> - WEEK <span id="hub-week">1</span></div>
            </div>
            <div class="turn-banner" id="turn-banner">PLAYER 1'S TURN</div>
            <div class="grid-3">
                <button class="btn" onclick="viewRoster()">üìã ROSTER</button>
                <button class="btn blue" onclick="scheduleFight()">ü•ä FIGHT</button>
                <button class="btn gold" onclick="trainFighter()">üí™ TRAIN</button>
                <button class="btn green" onclick="viewStandings()">üèÜ STANDINGS</button>
                <button class="btn" onclick="endTurn()">‚è≠Ô∏è END TURN</button>
                <button class="btn" onclick="saveGame()">üíæ SAVE</button>
            </div>
            <div class="commentary" id="hub-log"><p class="info">Welcome to Brotherhood Boxing!</p></div>
        </div>
        
        <div id="roster-screen" class="screen">
            <h2 class="title"><span id="roster-title">ROSTER</span></h2>
            <div id="roster-grid" class="grid-3"></div>
            <div class="divider"></div>
            <div style="text-align: center;"><button class="btn" onclick="showScreen('hub-screen')">BACK TO HUB</button></div>
        </div>
        
        <div id="fight-setup-screen" class="screen">
            <h2 class="title">SCHEDULE A FIGHT</h2>
            <div class="grid-2">
                <div class="panel">
                    <p class="subtitle">üî¥ RED CORNER - Select Fighter</p>
                    <div id="p1-select-grid"></div>
                </div>
                <div class="panel blue">
                    <p class="subtitle" style="color: #4da6ff;">üîµ BLUE CORNER - Select Fighter</p>
                    <div id="p2-select-grid"></div>
                </div>
            </div>
            <div class="divider"></div>
            <div style="text-align: center;">
                <button class="btn green large" onclick="confirmFight()">üîî RING THE BELL!</button>
                <button class="btn" onclick="showScreen('hub-screen')">CANCEL</button>
            </div>
        </div>
        
        <div id="prefight-screen" class="screen">
            <div class="round-display">
                <div class="round-num">FIGHT NIGHT</div>
                <div class="round-timer">MAIN EVENT - 12 ROUNDS</div>
            </div>
            <div class="grid-2">
                <div class="panel" id="prefight-p1"></div>
                <div class="panel blue" id="prefight-p2"></div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn green large" onclick="beginFight()">ü•ä LET'S GET READY TO RUMBLE!</button>
            </div>
        </div>
        
        <div id="fight-screen" class="screen">
            <div class="round-display">
                <div class="round-num">ROUND <span id="fight-round">1</span></div>
                <div class="round-timer" id="fight-timer">3:00</div>
            </div>
            <!-- Momentum Indicator -->
            <div class="momentum-indicator">
                <span style="font-size: 7px; color: #e94560; margin-right: 10px;">üî¥</span>
                <div class="momentum-bar">
                    <div class="momentum-marker" id="momentum-marker" style="left: 50%;"></div>
                </div>
                <span style="font-size: 7px; color: #4da6ff; margin-left: 10px;">üîµ</span>
            </div>
            <!-- Live Punch Stats -->
            <div class="punch-stats">
                <div style="color: #e94560;">
                    <span id="p1-landed">0</span>/<span id="p1-thrown">0</span> 
                    (<span id="p1-accuracy">0</span>%)
                </div>
                <div style="color: #888;">PUNCHES LANDED/THROWN</div>
                <div style="color: #4da6ff;">
                    <span id="p2-landed">0</span>/<span id="p2-thrown">0</span>
                    (<span id="p2-accuracy">0</span>%)
                </div>
            </div>
            <!-- Distance Indicator -->
            <div class="distance-indicator">
                <span>RANGE: </span><span id="fight-distance" class="distance-mid">MID-RANGE</span>
            </div>
            <div class="ring-container" id="ring-container">
                <div class="ring-canvas" id="ring-canvas">
                    <div class="fighter-hud left">
                        <div class="hud-name" id="hud-p1-name">FIGHTER 1</div>
                        <div class="hud-bar"><div class="hud-fill health" id="hud-p1-health" style="width: 100%"></div></div>
                        <div class="hud-bar"><div class="hud-fill stamina" id="hud-p1-stamina" style="width: 100%"></div></div>
                        <div id="hud-p1-injuries"></div>
                    </div>
                    <div class="fighter-hud right">
                        <div class="hud-name" id="hud-p2-name">FIGHTER 2</div>
                        <div class="hud-bar"><div class="hud-fill health" id="hud-p2-health" style="width: 100%"></div></div>
                        <div class="hud-bar"><div class="hud-fill stamina" id="hud-p2-stamina" style="width: 100%"></div></div>
                        <div id="hud-p2-injuries"></div>
                    </div>
                    <div class="ring-rope rope-1"></div>
                    <div class="ring-rope rope-2"></div>
                    <div class="ring-rope rope-3"></div>
                    <div class="ring-floor"></div>
                    <div class="ring-fighter left" id="fighter-1">
                        <div class="pixel-boxer">
                            <div class="boxer-head"></div>
                            <div class="boxer-body red"></div>
                            <div class="boxer-glove left-glove red"></div>
                            <div class="boxer-glove right-glove red"></div>
                            <div class="boxer-shorts red"></div>
                            <div class="boxer-legs"><div class="boxer-leg"></div><div class="boxer-leg"></div></div>
                        </div>
                    </div>
                    <div class="ring-fighter right" id="fighter-2">
                        <div class="pixel-boxer">
                            <div class="boxer-head"></div>
                            <div class="boxer-body blue"></div>
                            <div class="boxer-glove left-glove blue"></div>
                            <div class="boxer-glove right-glove blue"></div>
                            <div class="boxer-shorts blue"></div>
                            <div class="boxer-legs"><div class="boxer-leg"></div><div class="boxer-leg"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="commentary" id="fight-commentary"><p class="action">The fighters touch gloves. Here we go!</p></div>
            <div style="text-align: center;">
                <button class="btn gold large" id="sim-btn" onclick="simulateExchange()">‚è© SIMULATE EXCHANGE</button>
            </div>
        </div>
        
        <div id="corner-screen" class="screen">
            <div class="round-display">
                <div class="round-num">CORNER TIME</div>
                <div class="round-timer">60 SECONDS BETWEEN ROUNDS</div>
            </div>
            <p style="text-align: center; font-size: 9px; color: #ffdd00; margin: 15px 0;">
                MANAGERS: Apply treatments and set strategy for the next round!
            </p>
            <div class="grid-2">
                <div class="panel" id="corner-p1-panel">
                    <p class="subtitle">üî¥ RED CORNER</p>
                    <p class="hud-name" id="corner-p1-name">FIGHTER</p>
                    <div class="corner-section">
                        <div class="corner-stat"><span>Health:</span><span id="corner-p1-health" class="success">100%</span></div>
                        <div class="corner-stat"><span>Stamina:</span><span id="corner-p1-stamina" class="info">100%</span></div>
                        <div class="corner-stat"><span>Cuts:</span><span id="corner-p1-cuts">None</span></div>
                        <div class="corner-stat"><span>Swelling:</span><span id="corner-p1-swelling">None</span></div>
                    </div>
                    <p class="label" style="margin-top: 10px;">CUTMAN ACTIONS (pick one):</p>
                    <div class="corner-actions" id="p1-cutman-actions">
                        <button class="btn corner-btn" onclick="cutmanAction(1,'ice')">üßä ICE</button>
                        <button class="btn corner-btn" onclick="cutmanAction(1,'adrenaline')">üíâ STOP CUT</button>
                        <button class="btn corner-btn" onclick="cutmanAction(1,'water')">üíß WATER</button>
                        <button class="btn corner-btn" onclick="cutmanAction(1,'salts')">üëÉ SALTS</button>
                    </div>
                    <p class="label">TRAINER STRATEGY:</p>
                    <div class="corner-actions" id="p1-strategy-btns">
                        <button class="btn strategy-btn" data-strategy="aggressive" onclick="setStrategy(1,'aggressive')">üëä AGGRESSIVE</button>
                        <button class="btn strategy-btn" data-strategy="defensive" onclick="setStrategy(1,'defensive')">üõ°Ô∏è DEFENSIVE</button>
                        <button class="btn strategy-btn" data-strategy="body" onclick="setStrategy(1,'body')">üí™ BODY WORK</button>
                        <button class="btn strategy-btn" data-strategy="head" onclick="setStrategy(1,'head')">üéØ HEAD HUNTER</button>
                    </div>
                </div>
                <div class="panel blue" id="corner-p2-panel">
                    <p class="subtitle" style="color: #4da6ff;">üîµ BLUE CORNER</p>
                    <p class="hud-name" id="corner-p2-name">FIGHTER</p>
                    <div class="corner-section">
                        <div class="corner-stat"><span>Health:</span><span id="corner-p2-health" class="success">100%</span></div>
                        <div class="corner-stat"><span>Stamina:</span><span id="corner-p2-stamina" class="info">100%</span></div>
                        <div class="corner-stat"><span>Cuts:</span><span id="corner-p2-cuts">None</span></div>
                        <div class="corner-stat"><span>Swelling:</span><span id="corner-p2-swelling">None</span></div>
                    </div>
                    <p class="label" style="margin-top: 10px;">CUTMAN ACTIONS (pick one):</p>
                    <div class="corner-actions" id="p2-cutman-actions">
                        <button class="btn corner-btn blue" onclick="cutmanAction(2,'ice')">üßä ICE</button>
                        <button class="btn corner-btn blue" onclick="cutmanAction(2,'adrenaline')">üíâ STOP CUT</button>
                        <button class="btn corner-btn blue" onclick="cutmanAction(2,'water')">üíß WATER</button>
                        <button class="btn corner-btn blue" onclick="cutmanAction(2,'salts')">üëÉ SALTS</button>
                    </div>
                    <p class="label">TRAINER STRATEGY:</p>
                    <div class="corner-actions" id="p2-strategy-btns">
                        <button class="btn strategy-btn blue" data-strategy="aggressive" onclick="setStrategy(2,'aggressive')">üëä AGGRESSIVE</button>
                        <button class="btn strategy-btn blue" data-strategy="defensive" onclick="setStrategy(2,'defensive')">üõ°Ô∏è DEFENSIVE</button>
                        <button class="btn strategy-btn blue" data-strategy="body" onclick="setStrategy(2,'body')">üí™ BODY WORK</button>
                        <button class="btn strategy-btn blue" data-strategy="head" onclick="setStrategy(2,'head')">üéØ HEAD HUNTER</button>
                    </div>
                </div>
            </div>
            <div class="divider"></div>
            <div style="text-align: center;"><button class="btn green large" onclick="nextRound()">üîî SECONDS OUT!</button></div>
        </div>
        
        <div id="result-screen" class="screen">
            <div class="result-banner" id="result-banner">
                <div class="result-title">FIGHT OVER!</div>
                <div class="result-winner" id="result-winner">WINNER</div>
                <div class="result-method" id="result-method">BY DECISION</div>
            </div>
            <div class="scorecard" id="scorecard"></div>
            <div class="grid-2" id="result-stats"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn green large" onclick="returnToHub()">RETURN TO FRANCHISE</button>
            </div>
        </div>
        
        <div id="standings-screen" class="screen">
            <h2 class="title">üèÜ RANKINGS</h2>
            <div class="panel" id="standings-content"></div>
            <div style="text-align: center; margin-top: 15px;"><button class="btn" onclick="showScreen('hub-screen')">BACK</button></div>
        </div>
        
        <div class="modal" id="rules-modal">
            <div class="modal-box">
                <h2 class="modal-title">HOW TO PLAY</h2>
                <div class="modal-text">
                    <p class="highlight">ü•ä BROTHERHOOD BOXING</p>
                    <p>A two-player turn-based boxing manager simulation.</p><br>
                    <p class="highlight">üëî YOU ARE THE MANAGER</p>
                    <p>You don't control the boxers directly - you watch the fight simulation and make decisions between rounds!</p><br>
                    <p class="highlight">üìã FRANCHISE MODE</p>
                    <p>‚Ä¢ Each player takes turns managing their stable</p>
                    <p>‚Ä¢ Train your fighters to improve their stats</p>
                    <p>‚Ä¢ Schedule fights against your opponent's boxers</p><br>
                    <p class="highlight">ü•ä FIGHT NIGHT</p>
                    <p>‚Ä¢ Click "Simulate Exchange" to watch the AI fight</p>
                    <p>‚Ä¢ Between rounds, YOU become the corner man!</p><br>
                    <p class="highlight">ü©π CORNER CONTROLS</p>
                    <p>‚Ä¢ CUTMAN: Apply ice, stop cuts, give water</p>
                    <p>‚Ä¢ TRAINER: Set strategy for next round</p>
                    <p>‚Ä¢ Your choices affect how your fighter performs!</p><br>
                    <p class="highlight">üèÜ WIN THE SEASON</p>
                    <p>Build the best stable, win fights, earn money!</p>
                </div>
                <button class="btn" onclick="closeModal('rules-modal')" style="margin-top: 15px;">GOT IT!</button>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // BROTHERHOOD BOXING - GAME ENGINE
    // Two Player Turn-Based Manager Sim
    // ============================================

    // Game State
    const GameState = {
        players: [
            { name: 'Player 1', money: 50000, wins: 0, losses: 0, fighters: [] },
            { name: 'Player 2', money: 50000, wins: 0, losses: 0, fighters: [] }
        ],
        currentTurn: 0,
        season: 1,
        week: 1,
        activeFight: null,
        fightState: null
    };

    // Fighter Database - Starter Rosters
    function generateFighterId(playerKey) {
        // Prefer cryptographically strong UUIDs when available
        if (window.crypto && typeof window.crypto.randomUUID === 'function') {
            return playerKey + '-' + window.crypto.randomUUID();
        }
        // Fallback: timestamp + random string to reduce collision risk
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2, 8);
        return playerKey + '-' + timestamp + '-' + random;
    }

    const starterFighters = {
        player1: [
            { id: generateFighterId('player1'), name: 'IRON MIKE', style: 'Slugger', power: 88, speed: 75, stamina: 70, defense: 65, chin: 80, heart: 85, emoji: 'üëä' },
            { id: generateFighterId('player1'), name: 'QUICK HANDS', style: 'Outboxer', power: 70, speed: 90, stamina: 80, defense: 85, chin: 65, heart: 75, emoji: 'ü•ä' },
            { id: generateFighterId('player1'), name: 'THE TANK', style: 'Swarmer', power: 75, speed: 70, stamina: 95, defense: 70, chin: 90, heart: 95, emoji: 'üî•' }
        ],
        player2: [
            { id: generateFighterId('player2'), name: 'THUNDER', style: 'Slugger', power: 85, speed: 72, stamina: 75, defense: 68, chin: 82, heart: 80, emoji: '‚ö°' },
            { id: generateFighterId('player2'), name: 'THE GHOST', style: 'Outboxer', power: 68, speed: 92, stamina: 78, defense: 88, chin: 62, heart: 78, emoji: 'üëª' },
            { id: generateFighterId('player2'), name: 'WARRIOR', style: 'Swarmer', power: 78, speed: 68, stamina: 92, defense: 72, chin: 88, heart: 92, emoji: '‚öîÔ∏è' }
        ]
    };

    // Commentary lines - Enhanced with more variety and boxing-accurate descriptions
    const commentary = {
        jab: [
            '{attacker} lands a sharp jab!', 
            '{attacker} pops the jab!', 
            'Quick jab from {attacker}!',
            '{attacker} sticks the jab right down the pipe!',
            'Textbook jab from {attacker}!',
            '{attacker} measures with the jab!',
            'The jab finds its mark!',
            '{attacker}\'s jab snaps {defender}\'s head back!'
        ],
        cross: [
            '{attacker} throws a straight right!',
            'The cross lands flush for {attacker}!',
            '{attacker} uncorks a straight!',
            'Power shot from {attacker}!',
            '{attacker} steps in with the right hand!',
            'That cross had some mustard on it!'
        ],
        hook: [
            '{attacker} connects with a devastating hook!', 
            'HUGE hook by {attacker}!', 
            '{attacker} lands the hook!',
            'Left hook from {attacker} lands clean!',
            '{attacker} throws a sweeping hook!',
            'The hook catches {defender} on the temple!',
            'What a check hook from {attacker}!',
            '{attacker}\'s hook comes around the guard!'
        ],
        uppercut: [
            '{attacker} lands an uppercut!', 
            'BIG uppercut from {attacker}!', 
            '{attacker} finds the chin with an uppercut!',
            '{attacker} rips the uppercut through the middle!',
            'Vicious uppercut by {attacker}!',
            'The uppercut rises and lands!',
            '{attacker} comes up with the shovel shot!'
        ],
        miss: [
            '{attacker} misses!', 
            '{defender} dodges!', 
            '{attacker} swings and misses!',
            '{defender} slips the punch beautifully!',
            '{defender} makes {attacker} miss badly!',
            'Nothing but air on that one!',
            '{defender}\'s head movement is on point!',
            '{attacker} falls short!',
            '{defender} pulls back just in time!'
        ],
        block: [
            '{defender} blocks the shot!', 
            'Good defense by {defender}!', 
            '{defender} covers up!',
            '{defender} catches it on the gloves!',
            'That one lands on the arms!',
            '{defender} shows good guard work!',
            'Blocked by the high guard!',
            '{defender} absorbs it on the shell!'
        ],
        bodyShot: [
            '{attacker} digs to the body!', 
            'Body shot from {attacker}!', 
            '{attacker} goes downstairs!',
            '{attacker} targets the ribs!',
            'Liver shot from {attacker}!',
            '{attacker} buries one in the midsection!',
            'That body shot made {defender} wince!',
            '{attacker} is investing to the body!',
            'Punishing body work from {attacker}!'
        ],
        bigHit: [
            'WHAT A SHOT! {defender} is hurt!', 
            '{defender} is ROCKED!', 
            'DEVASTATING blow by {attacker}!',
            'OH! {defender} felt that one!',
            '{defender}\'s legs are gone!',
            'THUNDEROUS shot from {attacker}!',
            '{defender} is in serious trouble!',
            'That one buckled {defender}\'s knees!',
            'HUGE SHOT! The crowd is on their feet!'
        ],
        clinch: [
            'The fighters clinch...', 
            'They tie up in the center.', 
            'Break it up!',
            '{defender} holds on to recover...',
            'Smart clinch work to survive the moment.',
            'The referee separates them.'
        ],
        tired: [
            '{fighter} is showing signs of fatigue.', 
            '{fighter} is breathing heavy.', 
            '{fighter} needs to pace themselves.',
            '{fighter}\'s punch output is dropping.',
            '{fighter} looks gassed!',
            'The tank is running low for {fighter}.',
            '{fighter}\'s corner is screaming for more energy!'
        ],
        combo: [
            '{attacker} lands a combination!',
            '{attacker} goes 1-2!',
            'Nice combo from {attacker}!',
            '{attacker} strings together multiple shots!',
            '{attacker} lets their hands go!',
            'Flurry of punches from {attacker}!'
        ],
        counter: [
            '{defender} fires back with a counter!',
            'Beautiful counter by {defender}!',
            '{defender} makes them pay for that!',
            'Counter shot from {defender}!',
            '{defender} times it perfectly!'
        ],
        knockdown: [
            'DOWN GOES {defender}!',
            '{defender} IS DOWN!',
            'KNOCKDOWN! {defender} hits the canvas!',
            '{attacker} drops {defender}!',
            'THE CANVAS CATCHES {defender}!',
            '{defender} is on the deck!'
        ],
        recovery: [
            '{fighter} beats the count!',
            '{fighter} shows that heart!',
            '{fighter} is back on their feet!',
            '{fighter} survives!'
        ],
        ringControl: [
            '{fighter} is cutting off the ring!',
            '{fighter} has {defender} against the ropes!',
            '{fighter} is controlling the center!',
            '{fighter} is dictating the pace!'
        ],
        crowdReaction: [
            'The crowd erupts!',
            'Listen to this crowd!',
            'The arena is electric!',
            'The fans are loving this!'
        ]
    };

    // Punch types with realistic boxing mechanics
    const PUNCH_TYPES = {
        jab: { damage: 3, stamina: 2, speed: 1.2, accuracy: 1.15, name: 'JAB' },
        cross: { damage: 7, stamina: 4, speed: 0.9, accuracy: 0.95, name: 'CROSS' },
        hook: { damage: 9, stamina: 5, speed: 0.85, accuracy: 0.85, name: 'HOOK' },
        uppercut: { damage: 10, stamina: 6, speed: 0.75, accuracy: 0.80, name: 'UPPERCUT' },
        bodyJab: { damage: 4, stamina: 3, speed: 1.0, accuracy: 1.1, name: 'BODY JAB' },
        bodyHook: { damage: 8, stamina: 5, speed: 0.8, accuracy: 0.9, name: 'BODY HOOK' }
    };

    // Ring distance mechanics
    const RING_DISTANCES = {
        close: { 
            name: 'CLOSE RANGE', 
            class: 'distance-close',
            modifiers: { hook: 1.2, uppercut: 1.3, jab: 0.7, cross: 0.8 }
        },
        mid: { 
            name: 'MID-RANGE', 
            class: 'distance-mid',
            modifiers: { hook: 1.0, uppercut: 0.9, jab: 1.1, cross: 1.2 }
        },
        far: { 
            name: 'OUTSIDE', 
            class: 'distance-far',
            modifiers: { hook: 0.7, uppercut: 0.6, jab: 1.3, cross: 1.0 }
        }
    };

    // Utility Functions
    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
    }

    function showModal(modalId) {
        document.getElementById(modalId).classList.add('active');
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
    }

    function log(message, type = 'info') {
        const logEl = document.getElementById('hub-log');
        if (logEl) {
            const p = document.createElement('p');
            p.className = type;
            p.textContent = message;
            logEl.insertBefore(p, logEl.firstChild);
        }
    }

    function fightLog(message, type = 'action') {
        const logEl = document.getElementById('fight-commentary');
        if (logEl) {
            const p = document.createElement('p');
            p.className = type;
            p.textContent = message;
            logEl.appendChild(p);
            logEl.scrollTop = logEl.scrollHeight;
        }
    }

    function rand(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function pick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    // Menu Functions
    function startNewGame() {
        showScreen('setup-screen');
    }

    function loadGame() {
        const saved = localStorage.getItem('brotherhood_boxing_save');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                Object.assign(GameState, data);
                updateHubUI();
                showScreen('hub-screen');
                log('Game loaded!', 'action');
            } catch (e) {
                alert('No saved game found or save corrupted.');
            }
        } else {
            alert('No saved game found. Start a new franchise!');
        }
    }

    function saveGame() {
        try {
            localStorage.setItem('brotherhood_boxing_save', JSON.stringify(GameState));
            log('Game saved!', 'action');
        } catch (e) {
            log('Failed to save game. Storage may be full or unavailable.', 'hit');
            alert('Could not save game. Please check if you have storage space available.');
        }
    }

    function validatePlayerName(name) {
        // Allow alphanumeric characters, spaces, and common punctuation
        const sanitized = name.replace(/[^a-zA-Z0-9\s\-_.]/g, '').trim();
        if (sanitized.length === 0) return null;
        if (sanitized.length > 12) return sanitized.substring(0, 12);
        return sanitized;
    }

    function confirmSetup() {
        let p1Name = validatePlayerName(document.getElementById('p1-name-input').value) || 'PLAYER 1';
        let p2Name = validatePlayerName(document.getElementById('p2-name-input').value) || 'PLAYER 2';
        
        GameState.players[0].name = p1Name.toUpperCase();
        GameState.players[1].name = p2Name.toUpperCase();
        
        // Assign starter fighters
        GameState.players[0].fighters = JSON.parse(JSON.stringify(starterFighters.player1));
        GameState.players[1].fighters = JSON.parse(JSON.stringify(starterFighters.player2));
        
        updateHubUI();
        showScreen('hub-screen');
        log(`Franchise started! ${p1Name} vs ${p2Name}!`, 'action');
    }

    // Hub Functions
    function updateHubUI() {
        const p1 = GameState.players[0];
        const p2 = GameState.players[1];
        
        document.getElementById('hub-p1-name').textContent = p1.name;
        document.getElementById('hub-p2-name').textContent = p2.name;
        document.getElementById('hub-p1-money').textContent = '$' + p1.money.toLocaleString();
        document.getElementById('hub-p2-money').textContent = '$' + p2.money.toLocaleString();
        document.getElementById('hub-p1-record').textContent = p1.wins + '-' + p1.losses;
        document.getElementById('hub-p2-record').textContent = p2.wins + '-' + p2.losses;
        document.getElementById('hub-season').textContent = GameState.season;
        document.getElementById('hub-week').textContent = GameState.week;
        
        const turnBanner = document.getElementById('turn-banner');
        const currentPlayer = GameState.players[GameState.currentTurn];
        turnBanner.textContent = currentPlayer.name + "'S TURN";
        turnBanner.style.background = GameState.currentTurn === 0 
            ? 'linear-gradient(180deg, #e94560 0%, #b83250 100%)' 
            : 'linear-gradient(180deg, #4da6ff 0%, #0066cc 100%)';
        
        // Highlight active player panel
        document.getElementById('hub-p1-panel').style.boxShadow = GameState.currentTurn === 0 ? '0 0 15px rgba(233, 69, 96, 0.5)' : 'none';
        document.getElementById('hub-p2-panel').style.boxShadow = GameState.currentTurn === 1 ? '0 0 15px rgba(77, 166, 255, 0.5)' : 'none';
    }

    function endTurn() {
        GameState.currentTurn = GameState.currentTurn === 0 ? 1 : 0;
        
        // If back to player 1, advance week
        if (GameState.currentTurn === 0) {
            GameState.week++;
            if (GameState.week > 12) {
                GameState.week = 1;
                GameState.season++;
                log('NEW SEASON ' + GameState.season + '!', 'action');
            }
        }
        
        updateHubUI();
        log(GameState.players[GameState.currentTurn].name + "'s turn!", 'info');
    }

    // Roster Functions
    function viewRoster() {
        const player = GameState.players[GameState.currentTurn];
        document.getElementById('roster-title').textContent = player.name + "'S ROSTER";
        
        const grid = document.getElementById('roster-grid');
        grid.innerHTML = '';
        
        player.fighters.forEach(f => {
            grid.innerHTML += createFighterCard(f, false);
        });
        
        showScreen('roster-screen');
    }

    function createFighterCard(fighter, selectable = false, selected = false) {
        const ovr = Math.round((fighter.power + fighter.speed + fighter.stamina + fighter.defense + fighter.chin + fighter.heart) / 6);
        return `
            <div class="fighter-card ${selected ? 'selected' : ''}" 
                 ${selectable ? `onclick="selectFighter('${fighter.id}')"` : ''} 
                 data-id="${fighter.id}">
                <div class="fighter-sprite">${fighter.emoji}</div>
                <div class="fighter-name">${fighter.name}</div>
                <div class="label" style="text-align:center; margin-bottom: 8px;">${fighter.style} ‚Ä¢ OVR ${ovr}</div>
                <div class="stat-row"><span>PWR</span><div class="stat-bar"><div class="stat-fill" style="width:${fighter.power}%"></div></div></div>
                <div class="stat-row"><span>SPD</span><div class="stat-bar"><div class="stat-fill blue" style="width:${fighter.speed}%"></div></div></div>
                <div class="stat-row"><span>STA</span><div class="stat-bar"><div class="stat-fill green" style="width:${fighter.stamina}%"></div></div></div>
                <div class="stat-row"><span>DEF</span><div class="stat-bar"><div class="stat-fill" style="width:${fighter.defense}%"></div></div></div>
                <div class="stat-row"><span>CHN</span><div class="stat-bar"><div class="stat-fill" style="width:${fighter.chin}%"></div></div></div>
                <div class="stat-row"><span>HRT</span><div class="stat-bar"><div class="stat-fill" style="width:${fighter.heart}%"></div></div></div>
            </div>
        `;
    }

    // Training
    function trainFighter() {
        const player = GameState.players[GameState.currentTurn];
        
        // Ensure there is at least one fighter to train
        if (!player || !player.fighters || player.fighters.length === 0) {
            log('No fighters available to train.', 'hit');
            return;
        }

        // Select a random fighter to train
        const fighter = player.fighters[rand(0, player.fighters.length - 1)];

        // Initialize and enforce per-fighter training limits
        if (typeof fighter.trainingSessions !== 'number') {
            fighter.trainingSessions = 0;
        }

        const MAX_TRAINING_SESSIONS = 50;
        if (fighter.trainingSessions >= MAX_TRAINING_SESSIONS) {
            log(`${fighter.name} has reached their training limit. Focus on another fighter.`, 'hit');
            return;
        }

        // Dynamic training cost: starts at $5,000 and increases with each session
        const BASE_TRAINING_COST = 5000;
        const INCREMENTAL_COST = 500;
        const trainingCost = BASE_TRAINING_COST + (fighter.trainingSessions * INCREMENTAL_COST);

        if (player.money < trainingCost) {
            log(`Not enough money for training! Need $${trainingCost.toLocaleString()}.`, 'hit');
            return;
        }
        
        // Random stat boost
        const stats = ['power', 'speed', 'stamina', 'defense', 'chin', 'heart'];
        const stat = pick(stats);
        const boost = rand(1, 3);
        
        fighter[stat] = Math.min(99, fighter[stat] + boost);
        fighter.trainingSessions += 1;
        player.money -= trainingCost;
        
        log(`${fighter.name} trained ${stat.toUpperCase()} +${boost}! (-$${trainingCost.toLocaleString()})`, 'action');
        updateHubUI();
    }

    // Fight Setup
    let selectedP1Fighter = null;
    let selectedP2Fighter = null;

    function scheduleFight() {
        selectedP1Fighter = null;
        selectedP2Fighter = null;
        
        const p1Grid = document.getElementById('p1-select-grid');
        const p2Grid = document.getElementById('p2-select-grid');
        
        p1Grid.innerHTML = '';
        p2Grid.innerHTML = '';
        
        GameState.players[0].fighters.forEach(f => {
            p1Grid.innerHTML += createFighterCard(f, true, false);
        });
        
        GameState.players[1].fighters.forEach(f => {
            p2Grid.innerHTML += createFighterCard(f, true, false);
        });
        
        showScreen('fight-setup-screen');
    }

    function selectFighter(fighterId) {
        // Determine which roster this fighter belongs to
        const p1Fighter = GameState.players[0].fighters.find(f => f.id === fighterId);
        const p2Fighter = GameState.players[1].fighters.find(f => f.id === fighterId);
        
        if (p1Fighter) {
            selectedP1Fighter = p1Fighter;
            // Update UI
            document.querySelectorAll('#p1-select-grid .fighter-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.id === fighterId);
            });
        } else if (p2Fighter) {
            selectedP2Fighter = p2Fighter;
            document.querySelectorAll('#p2-select-grid .fighter-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.id === fighterId);
            });
        }
    }

    function confirmFight() {
        if (!selectedP1Fighter || !selectedP2Fighter) {
            alert('Both corners must select a fighter!');
            return;
        }
        
        // Setup pre-fight screen
        const p1Ovr = Math.round((selectedP1Fighter.power + selectedP1Fighter.speed + selectedP1Fighter.stamina + selectedP1Fighter.defense + selectedP1Fighter.chin + selectedP1Fighter.heart) / 6);
        const p2Ovr = Math.round((selectedP2Fighter.power + selectedP2Fighter.speed + selectedP2Fighter.stamina + selectedP2Fighter.defense + selectedP2Fighter.chin + selectedP2Fighter.heart) / 6);
        
        document.getElementById('prefight-p1').innerHTML = `
            <div class="fighter-sprite" style="font-size:48px; width:80px; height:100px;">${selectedP1Fighter.emoji}</div>
            <div class="fighter-name" style="font-size:14px; margin: 15px 0;">${selectedP1Fighter.name}</div>
            <div class="label">${selectedP1Fighter.style} ‚Ä¢ OVR ${p1Ovr}</div>
            <div class="label" style="margin-top: 10px;">Managed by ${GameState.players[0].name}</div>
        `;
        
        document.getElementById('prefight-p2').innerHTML = `
            <div class="fighter-sprite" style="font-size:48px; width:80px; height:100px;">${selectedP2Fighter.emoji}</div>
            <div class="fighter-name" style="font-size:14px; margin: 15px 0;">${selectedP2Fighter.name}</div>
            <div class="label">${selectedP2Fighter.style} ‚Ä¢ OVR ${p2Ovr}</div>
            <div class="label" style="margin-top: 10px;">Managed by ${GameState.players[1].name}</div>
        `;
        
        showScreen('prefight-screen');
    }

    // Fight System
    function beginFight() {
        // Initialize fight state with enhanced mechanics
        GameState.fightState = {
            round: 1,
            maxRounds: 12,
            exchangesThisRound: 0,
            maxExchangesPerRound: 8,
            isSimulating: false, // Flag to prevent concurrent exchanges
            distance: 'mid', // Ring control: 'close', 'mid', 'far'
            momentum: 50, // 0-100, 50 is neutral, <50 favors P1, >50 favors P2
            fighters: [
                {
                    ...selectedP1Fighter,
                    health: 100,
                    stamina: 100,
                    cuts: 0,
                    swelling: 0,
                    knockdowns: 0,
                    knockdownsThisRound: 0,
                    punchesLanded: 0,
                    punchesThrown: 0,
                    punchesMissed: 0,
                    powerPunchesLanded: 0,
                    bodyPunchesLanded: 0,
                    combosLanded: 0,
                    damageDealtThisRound: 0,
                    strategy: 'normal',
                    cutmanAction: null,
                    isHurt: false,
                    hurtTimer: 0
                },
                {
                    ...selectedP2Fighter,
                    health: 100,
                    stamina: 100,
                    cuts: 0,
                    swelling: 0,
                    knockdowns: 0,
                    knockdownsThisRound: 0,
                    punchesLanded: 0,
                    punchesThrown: 0,
                    punchesMissed: 0,
                    powerPunchesLanded: 0,
                    bodyPunchesLanded: 0,
                    combosLanded: 0,
                    damageDealtThisRound: 0,
                    strategy: 'normal',
                    cutmanAction: null,
                    isHurt: false,
                    hurtTimer: 0
                }
            ],
            scorecard: [],
            // Initialize round start health for round 1 scoring
            roundStartHealth: {
                f1: 100,
                f2: 100
            }
        };
        
        // Update HUD
        document.getElementById('hud-p1-name').textContent = selectedP1Fighter.name;
        document.getElementById('hud-p2-name').textContent = selectedP2Fighter.name;
        document.getElementById('fight-round').textContent = '1';
        document.getElementById('fight-commentary').innerHTML = '<p class="action">The fighters touch gloves and we\'re underway!</p>';
        
        // Reset punch stats display
        updatePunchStats();
        updateMomentum();
        updateDistance();
        
        updateFightHUD();
        showScreen('fight-screen');
        
        // Play bell sound
        playSound('bell');
    }

    // Sound system
    function playSound(type) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'bell':
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.3;
                    oscillator.start();
                    setTimeout(() => {
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    }, 100);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                case 'jab':
                    oscillator.frequency.value = 150;
                    oscillator.type = 'square';
                    gainNode.gain.value = 0.15;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'power':
                    oscillator.frequency.value = 80;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.value = 0.25;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.12);
                    break;
                case 'bigHit':
                    oscillator.frequency.value = 60;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.value = 0.35;
                    oscillator.start();
                    // Create impact effect
                    setTimeout(() => {
                        oscillator.frequency.value = 40;
                    }, 50);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'miss':
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.08;
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'crowd':
                    // White noise for crowd
                    const bufferSize = audioContext.sampleRate * 0.5;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    const noise = audioContext.createBufferSource();
                    noise.buffer = buffer;
                    const noiseGain = audioContext.createGain();
                    noiseGain.gain.value = 0.1;
                    noise.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    noise.start();
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    return;
            }
        } catch (e) {
            // Audio not supported or blocked, silently continue
        }
    }

    // Update punch statistics display
    function updatePunchStats() {
        const state = GameState.fightState;
        if (!state) return;
        
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        document.getElementById('p1-landed').textContent = f1.punchesLanded;
        document.getElementById('p1-thrown').textContent = f1.punchesThrown;
        document.getElementById('p1-accuracy').textContent = f1.punchesThrown > 0 ? Math.round((f1.punchesLanded / f1.punchesThrown) * 100) : 0;
        
        document.getElementById('p2-landed').textContent = f2.punchesLanded;
        document.getElementById('p2-thrown').textContent = f2.punchesThrown;
        document.getElementById('p2-accuracy').textContent = f2.punchesThrown > 0 ? Math.round((f2.punchesLanded / f2.punchesThrown) * 100) : 0;
    }

    // Update momentum indicator
    function updateMomentum() {
        const state = GameState.fightState;
        if (!state) return;
        
        const marker = document.getElementById('momentum-marker');
        if (marker) {
            marker.style.left = state.momentum + '%';
        }
    }

    // Update distance indicator
    function updateDistance() {
        const state = GameState.fightState;
        if (!state) return;
        
        const distanceEl = document.getElementById('fight-distance');
        if (distanceEl) {
            const distanceInfo = RING_DISTANCES[state.distance];
            distanceEl.textContent = distanceInfo.name;
            distanceEl.className = distanceInfo.class;
        }
    }

    function updateFightHUD() {
        const f1 = GameState.fightState.fighters[0];
        const f2 = GameState.fightState.fighters[1];
        
        const h1 = document.getElementById('hud-p1-health');
        const h2 = document.getElementById('hud-p2-health');
        const s1 = document.getElementById('hud-p1-stamina');
        const s2 = document.getElementById('hud-p2-stamina');
        
        h1.style.width = f1.health + '%';
        h2.style.width = f2.health + '%';
        s1.style.width = f1.stamina + '%';
        s2.style.width = f2.stamina + '%';
        
        h1.classList.toggle('low', f1.health < 30);
        h2.classList.toggle('low', f2.health < 30);
        
        // Injuries
        let inj1 = '';
        let inj2 = '';
        if (f1.cuts > 0) inj1 += '<span class="injury-tag cut">CUT</span>';
        if (f1.swelling > 0) inj1 += '<span class="injury-tag swelling">SWELLING</span>';
        if (f2.cuts > 0) inj2 += '<span class="injury-tag cut">CUT</span>';
        if (f2.swelling > 0) inj2 += '<span class="injury-tag swelling">SWELLING</span>';
        
        document.getElementById('hud-p1-injuries').innerHTML = inj1;
        document.getElementById('hud-p2-injuries').innerHTML = inj2;
    }

    function simulateExchange() {
        const state = GameState.fightState;
        if (!state) return;
        
        // Prevent concurrent exchanges from rapid clicking
        if (state.isSimulating) return;
        state.isSimulating = true;
        
        // Disable button during exchange
        const simBtn = document.getElementById('sim-btn');
        if (simBtn) simBtn.disabled = true;
        
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        // Update ring distance based on fighter styles and strategies
        updateRingDistance(f1, f2, state);
        
        // Determine who attacks first based on speed and aggression
        const f1Initiative = f1.speed + (f1.aggression || 70) + rand(-10, 10);
        const f2Initiative = f2.speed + (f2.aggression || 70) + rand(-10, 10);
        
        // Check for combo opportunities
        const comboChance1 = calculateComboChance(f1, f2, state);
        const comboChance2 = calculateComboChance(f2, f1, state);
        
        if (f1Initiative >= f2Initiative) {
            // Fighter 1 attacks first
            simulateEnhancedPunch(f1, f2, 0, state);
            
            setTimeout(() => {
                // Check if defender can counter
                if (f2.health > 0 && !f2.isHurt) {
                    if (rand(1, 100) <= 20 + (f2.speed - f1.defense) / 3) {
                        fightLog(pick(commentary.counter).replace('{attacker}', f2.name).replace('{defender}', f2.name), 'action');
                    }
                    simulateEnhancedPunch(f2, f1, 1, state);
                }
                finishExchange(state, simBtn);
            }, 400);
        } else {
            // Fighter 2 attacks first
            simulateEnhancedPunch(f2, f1, 1, state);
            
            setTimeout(() => {
                if (f1.health > 0 && !f1.isHurt) {
                    if (rand(1, 100) <= 20 + (f1.speed - f2.defense) / 3) {
                        fightLog(pick(commentary.counter).replace('{attacker}', f1.name).replace('{defender}', f1.name), 'action');
                    }
                    simulateEnhancedPunch(f1, f2, 0, state);
                }
                finishExchange(state, simBtn);
            }, 400);
        }
        
        // Chance for combo punches
        if (rand(1, 100) <= comboChance1 && f1.stamina > 20) {
            setTimeout(() => {
                if (f2.health > 0 && f1.stamina > 15) {
                    fightLog(pick(commentary.combo).replace('{attacker}', f1.name), 'action');
                    simulateEnhancedPunch(f1, f2, 0, state);
                    f1.combosLanded++;
                }
            }, 600);
        }
        
        if (rand(1, 100) <= comboChance2 && f2.stamina > 20) {
            setTimeout(() => {
                if (f1.health > 0 && f2.stamina > 15) {
                    fightLog(pick(commentary.combo).replace('{attacker}', f2.name), 'action');
                    simulateEnhancedPunch(f2, f1, 1, state);
                    f2.combosLanded++;
                }
            }, 700);
        }
    }

    function finishExchange(state, simBtn) {
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        // Check for knockdown/KO
        if (f1.health <= 0 || f2.health <= 0) {
            state.isSimulating = false;
            playSound('bigHit');
            triggerScreenShake(true);
            endFight(f1.health <= 0 ? 1 : 0, 'KO');
            return;
        }
        
        // Base stamina drain based on activity
        const staminaDrain1 = rand(2, 4) + (f1.strategy === 'aggressive' ? 2 : 0);
        const staminaDrain2 = rand(2, 4) + (f2.strategy === 'aggressive' ? 2 : 0);
        
        f1.stamina = Math.max(0, f1.stamina - staminaDrain1);
        f2.stamina = Math.max(0, f2.stamina - staminaDrain2);
        
        // Update hurt status decay
        if (f1.isHurt) {
            f1.hurtTimer--;
            if (f1.hurtTimer <= 0) f1.isHurt = false;
        }
        if (f2.isHurt) {
            f2.hurtTimer--;
            if (f2.hurtTimer <= 0) f2.isHurt = false;
        }
        
        // Update momentum based on damage dealt this exchange
        const momentumShift = (f1.damageDealtThisRound - f2.damageDealtThisRound) / 5;
        state.momentum = Math.max(5, Math.min(95, state.momentum - momentumShift));
        
        // Check for fatigue commentary
        if (f1.stamina < 30 && rand(1, 100) <= 30) {
            fightLog(pick(commentary.tired).replace('{fighter}', f1.name), 'info');
        }
        if (f2.stamina < 30 && rand(1, 100) <= 30) {
            fightLog(pick(commentary.tired).replace('{fighter}', f2.name), 'info');
        }
        
        state.exchangesThisRound++;
        updateFightHUD();
        updatePunchStats();
        updateMomentum();
        updateDistance();
        
        // Re-enable button and flag
        state.isSimulating = false;
        if (simBtn) simBtn.disabled = false;
        
        // Check if round is over
        if (state.exchangesThisRound >= state.maxExchangesPerRound) {
            endRound();
        }
    }

    function updateRingDistance(f1, f2, state) {
        // Distance changes based on styles and strategies
        let distanceChange = 0;
        
        // Swarmers and aggressive fighters close distance
        if (f1.style === 'Swarmer' || f1.strategy === 'aggressive') distanceChange -= 1;
        if (f2.style === 'Swarmer' || f2.strategy === 'aggressive') distanceChange += 1;
        
        // Outboxers try to keep distance
        if (f1.style === 'Outboxer' || f1.strategy === 'defensive') distanceChange += 1;
        if (f2.style === 'Outboxer' || f2.strategy === 'defensive') distanceChange -= 1;
        
        // Random movement factor
        distanceChange += rand(-1, 1);
        
        // Apply distance changes
        const distances = ['close', 'mid', 'far'];
        let currentIdx = distances.indexOf(state.distance);
        currentIdx = Math.max(0, Math.min(2, currentIdx + Math.sign(distanceChange)));
        state.distance = distances[currentIdx];
        
        // Ring control commentary
        if (rand(1, 100) <= 10) {
            const controller = state.momentum < 50 ? f1 : f2;
            fightLog(pick(commentary.ringControl).replace('{fighter}', controller.name).replace('{defender}', controller === f1 ? f2.name : f1.name), 'info');
        }
    }

    function calculateComboChance(attacker, defender, state) {
        let chance = 15; // Base combo chance
        
        // Speed increases combo chance
        chance += (attacker.speed - 70) / 3;
        
        // Hurt opponents are easier to combo
        if (defender.isHurt) chance += 20;
        
        // Aggressive strategy increases combo chance
        if (attacker.strategy === 'aggressive') chance += 10;
        
        // Low stamina reduces combo chance
        chance *= (attacker.stamina / 100);
        
        // Style bonuses
        if (attacker.style === 'Swarmer') chance += 15;
        
        return Math.max(5, Math.min(40, chance));
    }

    function simulateEnhancedPunch(attacker, defender, attackerIndex, state) {
        // Select punch type based on distance, style, and strategy
        const punchType = selectPunchType(attacker, defender, state);
        const punchData = PUNCH_TYPES[punchType];
        
        attacker.punchesThrown++;
        
        // Calculate hit chance with all factors
        let hitChance = 40 + (attacker.speed * punchData.speed - defender.defense) / 2;
        hitChance *= punchData.accuracy;
        
        // Distance modifiers
        const distanceModifiers = RING_DISTANCES[state.distance].modifiers;
        const distanceMod = distanceModifiers[punchType] || distanceModifiers[punchType.replace('body', '')] || 1.0;
        hitChance *= distanceMod;
        
        // Strategy modifiers
        if (attacker.strategy === 'aggressive') hitChance += 8;
        if (attacker.strategy === 'defensive') hitChance -= 12;
        if (defender.strategy === 'defensive') hitChance -= 15;
        
        // Stamina affects accuracy significantly
        const staminaFactor = 0.5 + (attacker.stamina / 200);
        hitChance *= staminaFactor;
        
        // Hurt fighters are easier to hit
        if (defender.isHurt) hitChance += 20;
        
        // Swelling affects defense
        if (defender.swelling > 20) hitChance += Math.floor(defender.swelling / 10);
        
        // Clamp hit chance
        hitChance = Math.max(10, Math.min(90, hitChance));
        
        const roll = rand(1, 100);
        
        if (roll <= hitChance) {
            // Hit!
            let damage = punchData.damage + Math.floor(attacker.power / 10);
            
            // Apply distance modifier to damage
            damage = Math.floor(damage * distanceMod);
            
            // Strategy damage modifiers
            if (attacker.strategy === 'aggressive') damage = Math.floor(damage * 1.15);
            if (attacker.strategy === 'body') damage = Math.floor(damage * 0.9);
            if (attacker.strategy === 'head') damage = Math.floor(damage * 1.25);
            if (defender.strategy === 'defensive') damage = Math.floor(damage * 0.7);
            
            // Chin reduces damage
            damage = Math.floor(damage * (100 - Math.floor(defender.chin / 2)) / 100);
            
            // Critical hit chance (power punches)
            const isCritical = rand(1, 100) <= 5 + (attacker.power - 70) / 5;
            if (isCritical && punchType !== 'jab' && punchType !== 'bodyJab') {
                damage = Math.floor(damage * 1.5);
            }
            
            // Apply damage
            defender.health = Math.max(0, defender.health - damage);
            attacker.punchesLanded++;
            attacker.damageDealtThisRound += damage;
            
            // Track punch types
            if (punchType !== 'jab' && punchType !== 'bodyJab') {
                attacker.powerPunchesLanded++;
            }
            if (punchType === 'bodyJab' || punchType === 'bodyHook') {
                attacker.bodyPunchesLanded++;
                // Body shots drain stamina
                defender.stamina = Math.max(0, defender.stamina - rand(2, 5));
            }
            
            // Drain attacker stamina for punch
            attacker.stamina = Math.max(0, attacker.stamina - punchData.stamina);
            
            // Check for big hit / hurt status
            const isBigHit = damage > 12 || isCritical;
            if (isBigHit) {
                defender.isHurt = true;
                defender.hurtTimer = 2;
                
                // Knockdown check
                const knockdownChance = (damage - 10) * 2 + (100 - defender.chin) / 3 + (100 - defender.heart) / 5;
                if (rand(1, 100) <= knockdownChance) {
                    defender.knockdowns++;
                    defender.knockdownsThisRound++;
                    fightLog(pick(commentary.knockdown).replace('{attacker}', attacker.name).replace('{defender}', defender.name), 'hit');
                    playSound('bigHit');
                    triggerScreenShake(true);
                    triggerKnockdownEffect();
                    
                    // Recovery based on heart and health
                    const recoveryChance = defender.heart + defender.health / 2;
                    if (rand(1, 100) <= recoveryChance && defender.knockdownsThisRound < 3) {
                        fightLog(pick(commentary.recovery).replace('{fighter}', defender.name), 'action');
                        defender.health = Math.max(10, defender.health - 5); // Standing 8 count damage
                    } else {
                        defender.health = 0; // TKO
                    }
                    
                    // Three knockdown rule
                    if (defender.knockdownsThisRound >= 3) {
                        fightLog('THREE KNOCKDOWN RULE! The fight is stopped!', 'hit');
                        defender.health = 0;
                    }
                    return;
                }
            }
            
            // Cut/swelling chance on head shots
            if ((attacker.strategy === 'head' || punchType === 'hook' || punchType === 'uppercut') && rand(1, 100) <= 12) {
                if (rand(1, 2) === 1) {
                    defender.cuts = Math.min(100, defender.cuts + rand(10, 25));
                    fightLog(`${defender.name} has been CUT!`, 'hit');
                } else {
                    defender.swelling = Math.min(100, defender.swelling + rand(10, 20));
                    fightLog(`${defender.name}'s eye is swelling!`, 'hit');
                }
                
                // Doctor stoppage check
                if (defender.cuts >= 75 || defender.swelling >= 75) {
                    fightLog(`The doctor stops the fight due to ${defender.name}'s severe injuries!`, 'hit');
                    defender.health = 0;
                    return;
                }
            }
            
            // Commentary based on punch type and impact
            let commentaryType = punchType;
            if (punchType === 'bodyJab' || punchType === 'bodyHook') commentaryType = 'bodyShot';
            if (isBigHit) commentaryType = 'bigHit';
            
            let line = pick(commentary[commentaryType] || commentary.jab).replace('{attacker}', attacker.name).replace('{defender}', defender.name);
            fightLog(line, 'hit');
            
            // Sound and visual effects
            if (isBigHit) {
                playSound('bigHit');
                triggerScreenShake(false);
            } else if (punchType === 'jab' || punchType === 'bodyJab') {
                playSound('jab');
            } else {
                playSound('power');
            }
            
            // Animate
            animatePunch(attackerIndex, isBigHit);
            
            // Crowd reaction for big moments
            if (isBigHit && rand(1, 100) <= 50) {
                setTimeout(() => {
                    fightLog(pick(commentary.crowdReaction), 'info');
                    playSound('crowd');
                }, 300);
            }
            
        } else {
            // Miss
            attacker.punchesMissed++;
            attacker.stamina = Math.max(0, attacker.stamina - Math.floor(punchData.stamina / 2));
            
            const line = pick(commentary.miss).replace('{attacker}', attacker.name).replace('{defender}', defender.name);
            fightLog(line, 'info');
            playSound('miss');
        }
    }

    function selectPunchType(attacker, defender, state) {
        const distance = state.distance;
        const strategy = attacker.strategy;
        const style = attacker.style;
        
        // Weight punch selection based on distance and strategy
        let punchWeights = {
            jab: 40,
            cross: 20,
            hook: 15,
            uppercut: 10,
            bodyJab: 10,
            bodyHook: 5
        };
        
        // Distance adjustments
        if (distance === 'close') {
            punchWeights.hook += 15;
            punchWeights.uppercut += 15;
            punchWeights.jab -= 15;
            punchWeights.cross -= 10;
        } else if (distance === 'far') {
            punchWeights.jab += 20;
            punchWeights.cross += 10;
            punchWeights.hook -= 10;
            punchWeights.uppercut -= 10;
        }
        
        // Strategy adjustments
        if (strategy === 'body') {
            punchWeights.bodyJab += 25;
            punchWeights.bodyHook += 20;
        } else if (strategy === 'head') {
            punchWeights.hook += 10;
            punchWeights.uppercut += 15;
            punchWeights.bodyJab -= 10;
            punchWeights.bodyHook -= 5;
        } else if (strategy === 'aggressive') {
            punchWeights.hook += 10;
            punchWeights.cross += 10;
        }
        
        // Style adjustments
        if (style === 'Slugger') {
            punchWeights.hook += 15;
            punchWeights.cross += 10;
            punchWeights.jab -= 10;
        } else if (style === 'Outboxer') {
            punchWeights.jab += 20;
            punchWeights.cross += 5;
            punchWeights.hook -= 5;
        } else if (style === 'Swarmer') {
            punchWeights.jab += 10;
            punchWeights.bodyJab += 15;
            punchWeights.bodyHook += 10;
        }
        
        // Normalize and select
        const total = Object.values(punchWeights).reduce((a, b) => a + Math.max(0, b), 0);
        let roll = rand(1, total);
        
        for (const [punch, weight] of Object.entries(punchWeights)) {
            if (weight > 0) {
                roll -= weight;
                if (roll <= 0) return punch;
            }
        }
        
        return 'jab'; // Default
    }

    function animatePunch(attackerIndex, isBigHit) {
        const fighterEl = document.getElementById(attackerIndex === 0 ? 'fighter-1' : 'fighter-2');
        const defenderEl = document.getElementById(attackerIndex === 0 ? 'fighter-2' : 'fighter-1');
        
        if (isBigHit) {
            fighterEl.classList.add(attackerIndex === 0 ? 'power-punching' : 'power-punching-right');
            defenderEl.classList.add('staggered');
        } else {
            fighterEl.classList.add(attackerIndex === 0 ? 'punching' : 'punching-right');
            defenderEl.classList.add('hit-effect');
        }
        
        setTimeout(() => {
            fighterEl.classList.remove('punching', 'punching-right', 'power-punching', 'power-punching-right');
            defenderEl.classList.remove('hit-effect', 'staggered');
        }, isBigHit ? 500 : 300);
    }

    function triggerScreenShake(isKnockdown) {
        const ringContainer = document.getElementById('ring-container');
        if (ringContainer) {
            ringContainer.classList.add('screen-shake');
            setTimeout(() => {
                ringContainer.classList.remove('screen-shake');
            }, isKnockdown ? 600 : 400);
        }
    }

    function triggerKnockdownEffect() {
        const ringCanvas = document.getElementById('ring-canvas');
        if (ringCanvas) {
            ringCanvas.classList.add('knockdown-flash');
            setTimeout(() => {
                ringCanvas.classList.remove('knockdown-flash');
            }, 500);
        }
    }

    function endRound() {
        const state = GameState.fightState;
        
        // Score the round using enhanced 10-point must system
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        let p1Score = 10;
        let p2Score = 10;
        
        // Calculate round effectiveness for each fighter
        const f1Effectiveness = calculateRoundEffectiveness(f1, f2, state);
        const f2Effectiveness = calculateRoundEffectiveness(f2, f1, state);
        
        // Determine round winner and margin
        const scoreDiff = f1Effectiveness - f2Effectiveness;
        
        if (scoreDiff > 15) {
            // Dominant round for F1
            p2Score = 8;
            fightLog(`Dominant round for ${f1.name}!`, 'action');
        } else if (scoreDiff > 5) {
            // Clear round for F1
            p2Score = 9;
        } else if (scoreDiff < -15) {
            // Dominant round for F2
            p1Score = 8;
            fightLog(`Dominant round for ${f2.name}!`, 'action');
        } else if (scoreDiff < -5) {
            // Clear round for F2
            p1Score = 9;
        }
        // else: Even round, 10-10
        
        // Knockdown scoring - each knockdown is worth additional -1 point
        if (f1.knockdownsThisRound > 0) {
            p1Score = Math.max(7, p1Score - f1.knockdownsThisRound);
        }
        if (f2.knockdownsThisRound > 0) {
            p2Score = Math.max(7, p2Score - f2.knockdownsThisRound);
        }
        
        state.scorecard.push({ 
            round: state.round, 
            p1: p1Score, 
            p2: p2Score,
            f1Landed: f1.damageDealtThisRound,
            f2Landed: f2.damageDealtThisRound
        });
        
        // Calculate running totals
        let p1Total = 0, p2Total = 0;
        state.scorecard.forEach(r => {
            p1Total += r.p1;
            p2Total += r.p2;
        });
        
        // Announce round scores
        fightLog(`‚ïê‚ïê‚ïê END OF ROUND ${state.round} ‚ïê‚ïê‚ïê`, 'info');
        fightLog(`Round Score: ${p1Score}-${p2Score}`, 'info');
        fightLog(`Total: ${p1.name} ${p1Total} - ${p2Total} ${f2.name}`, 'info');
        
        // Play bell sound
        playSound('bell');
        
        // Check if fight is over
        if (state.round >= state.maxRounds) {
            // Go to decision
            if (p1Total > p2Total) {
                const margin = p1Total - p2Total;
                const method = margin > 10 ? 'UNANIMOUS DECISION' : margin > 5 ? 'SPLIT DECISION' : 'MAJORITY DECISION';
                endFight(0, method);
            } else if (p2Total > p1Total) {
                const margin = p2Total - p1Total;
                const method = margin > 10 ? 'UNANIMOUS DECISION' : margin > 5 ? 'SPLIT DECISION' : 'MAJORITY DECISION';
                endFight(1, method);
            } else {
                endFight(-1, 'DRAW');
            }
            return;
        }
        
        // Go to corner
        state.round++;
        state.exchangesThisRound = 0;
        
        // Reset round-specific stats
        state.fighters[0].cutmanAction = null;
        state.fighters[1].cutmanAction = null;
        state.fighters[0].damageDealtThisRound = 0;
        state.fighters[1].damageDealtThisRound = 0;
        state.fighters[0].knockdownsThisRound = 0;
        state.fighters[1].knockdownsThisRound = 0;
        
        // Clear hurt status between rounds
        state.fighters[0].isHurt = false;
        state.fighters[1].isHurt = false;
        state.fighters[0].hurtTimer = 0;
        state.fighters[1].hurtTimer = 0;
        
        showCornerScreen();
    }

    function calculateRoundEffectiveness(fighter, opponent, state) {
        let effectiveness = 0;
        
        // Damage dealt is primary factor
        effectiveness += fighter.damageDealtThisRound * 2;
        
        // Punches landed (adjusted by accuracy)
        const thrown = fighter.punchesThrown || 1;
        const accuracy = fighter.punchesLanded / thrown;
        effectiveness += fighter.punchesLanded * accuracy * 0.5;
        
        // Power punches count more
        effectiveness += (fighter.powerPunchesLanded || 0) * 1.5;
        
        // Ring control (momentum advantage)
        if (state.momentum < 50) {
            effectiveness += (50 - state.momentum) * 0.3;
        }
        
        // Knockdowns are huge
        effectiveness += (fighter.knockdownsThisRound || 0) * 20;
        
        // Penalty for being hurt
        if (opponent.knockdownsThisRound > 0) {
            effectiveness -= 10;
        }
        
        return effectiveness;
    }

    function showCornerScreen() {
        const state = GameState.fightState;
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        document.getElementById('corner-p1-name').textContent = f1.name;
        document.getElementById('corner-p2-name').textContent = f2.name;
        
        document.getElementById('corner-p1-health').textContent = Math.round(f1.health) + '%';
        document.getElementById('corner-p1-stamina').textContent = Math.round(f1.stamina) + '%';
        document.getElementById('corner-p1-cuts').textContent = f1.cuts > 0 ? 'Level ' + Math.ceil(f1.cuts / 25) : 'None';
        document.getElementById('corner-p1-swelling').textContent = f1.swelling > 0 ? 'Level ' + Math.ceil(f1.swelling / 25) : 'None';
        
        document.getElementById('corner-p2-health').textContent = Math.round(f2.health) + '%';
        document.getElementById('corner-p2-stamina').textContent = Math.round(f2.stamina) + '%';
        document.getElementById('corner-p2-cuts').textContent = f2.cuts > 0 ? 'Level ' + Math.ceil(f2.cuts / 25) : 'None';
        document.getElementById('corner-p2-swelling').textContent = f2.swelling > 0 ? 'Level ' + Math.ceil(f2.swelling / 25) : 'None';
        
        // Generate and display coach advice
        const advice1 = generateCoachAdvice(f1, f2, state, 0);
        const advice2 = generateCoachAdvice(f2, f1, state, 1);
        
        // Add coach advice elements if they don't exist
        let adviceEl1 = document.getElementById('coach-advice-1');
        let adviceEl2 = document.getElementById('coach-advice-2');
        
        if (!adviceEl1) {
            const panel1 = document.getElementById('corner-p1-panel');
            if (panel1) {
                adviceEl1 = document.createElement('div');
                adviceEl1.id = 'coach-advice-1';
                adviceEl1.style.cssText = 'margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; font-size: 7px; color: #ffdd00;';
                panel1.appendChild(adviceEl1);
            }
        }
        
        if (!adviceEl2) {
            const panel2 = document.getElementById('corner-p2-panel');
            if (panel2) {
                adviceEl2 = document.createElement('div');
                adviceEl2.id = 'coach-advice-2';
                adviceEl2.style.cssText = 'margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; font-size: 7px; color: #ffdd00;';
                panel2.appendChild(adviceEl2);
            }
        }
        
        if (adviceEl1) adviceEl1.innerHTML = `<strong>üé§ COACH:</strong> ${advice1}`;
        if (adviceEl2) adviceEl2.innerHTML = `<strong>üé§ COACH:</strong> ${advice2}`;
        
        // Reset button states (keep corner action buttons enabled, preserve strategy selections)
        document.querySelectorAll('.corner-btn').forEach(btn => btn.disabled = false);
        
        showScreen('corner-screen');
    }

    function generateCoachAdvice(fighter, opponent, state, fighterIndex) {
        const adviceOptions = [];
        
        // Calculate current scorecard totals
        let fighterTotal = 0, opponentTotal = 0;
        state.scorecard.forEach(r => {
            fighterTotal += fighterIndex === 0 ? r.p1 : r.p2;
            opponentTotal += fighterIndex === 0 ? r.p2 : r.p1;
        });
        
        const scoreDiff = fighterTotal - opponentTotal;
        const roundsRemaining = state.maxRounds - state.round + 1;
        
        // Stamina-based advice
        if (fighter.stamina < 40) {
            adviceOptions.push("You need to pace yourself! Conserve energy and pick your shots.");
            adviceOptions.push("Take a breather out there. Use the jab to control distance.");
        }
        
        if (opponent.stamina < 40) {
            adviceOptions.push("They're gassing! Now's the time to pour it on!");
            adviceOptions.push("Push the pace! They can't keep up much longer!");
        }
        
        // Health-based advice
        if (fighter.health < 50) {
            adviceOptions.push("Stay smart! Don't trade with them. Box from the outside.");
            adviceOptions.push("Protect yourself! Use your jab and keep moving.");
        }
        
        if (opponent.health < 50) {
            adviceOptions.push("They're hurt! Go for the finish! This is your moment!");
            adviceOptions.push("One big shot could end this! Look for the knockout!");
        }
        
        // Scoring-based advice
        if (scoreDiff > 6) {
            adviceOptions.push("You're ahead on the cards. Don't do anything stupid - box smart.");
            adviceOptions.push("Keep doing what you're doing. The fight is yours to lose.");
        } else if (scoreDiff < -6) {
            adviceOptions.push("You need a knockout to win this! Throw caution to the wind!");
            adviceOptions.push("You're behind! Time to take some risks!");
        }
        
        // Injury-based advice
        if (fighter.cuts > 30) {
            adviceOptions.push("Watch that cut! Don't let them target it.");
        }
        if (opponent.cuts > 30) {
            adviceOptions.push("Target that cut! A doctor stoppage is within reach!");
        }
        
        if (fighter.swelling > 30) {
            adviceOptions.push("That eye is closing up. Keep your guard high!");
        }
        if (opponent.swelling > 30) {
            adviceOptions.push("Their vision is impaired! Attack from their blind side!");
        }
        
        // Style-specific advice
        if (fighter.style === 'Slugger') {
            adviceOptions.push("Let your hands go! You've got the power to end this!");
        } else if (fighter.style === 'Outboxer') {
            adviceOptions.push("Stick to your jab. Control the range and pick them apart.");
        } else if (fighter.style === 'Swarmer') {
            adviceOptions.push("Get inside and work! Don't give them room to breathe!");
        }
        
        // Default advice
        if (adviceOptions.length === 0) {
            adviceOptions.push("Stay focused! Stick to the game plan!");
            adviceOptions.push("Good work! Keep that intensity up!");
            adviceOptions.push("Listen to your body. Make every punch count!");
        }
        
        return pick(adviceOptions);
    }

    // Corner Actions
    function cutmanAction(player, action) {
        const f = GameState.fightState.fighters[player - 1];
        
        if (f.cutmanAction) {
            return; // Already used action
        }
        
        f.cutmanAction = action;
        
        switch(action) {
            case 'ice':
                f.swelling = Math.max(0, f.swelling - 30);
                break;
            case 'adrenaline':
                f.cuts = Math.max(0, f.cuts - 40);
                break;
            case 'water':
                f.stamina = Math.min(100, f.stamina + 25);
                break;
            case 'salts':
                // Smelling salts boost alertness, modeled as health recovery
                f.health = Math.min(100, f.health + 5);
                f.stamina = Math.min(100, f.stamina + 10);
                break;
        }
        
        // Disable buttons for this player
        document.querySelectorAll(`#p${player}-cutman-actions .corner-btn`).forEach(btn => {
            btn.disabled = true;
        });
    }

    function setStrategy(player, strategy) {
        const f = GameState.fightState.fighters[player - 1];
        f.strategy = strategy;
        
        // Update button states using data-strategy attribute
        const btns = document.querySelectorAll(`#p${player}-strategy-btns .strategy-btn`);
        btns.forEach(btn => {
            btn.classList.remove('selected');
            if (btn.dataset.strategy === strategy) {
                btn.classList.add('selected');
            }
        });
    }

    function nextRound() {
        const state = GameState.fightState;
        
        // Apply natural recovery based on fighter conditioning
        state.fighters.forEach(f => {
            // Base stamina recovery
            let staminaRecovery = 15;
            
            // Better conditioned fighters recover more
            staminaRecovery += Math.floor((f.stamina_base || f.stamina) / 20);
            
            f.stamina = Math.min(100, f.stamina + staminaRecovery);
        });
        
        // Track health at start of round for scoring
        state.roundStartHealth = {
            f1: state.fighters[0].health,
            f2: state.fighters[1].health
        };
        
        // Reset distance to mid-range at start of each round
        state.distance = 'mid';
        
        // Play bell sound
        playSound('bell');
        
        // Update UI
        document.getElementById('fight-round').textContent = state.round;
        fightLog(`‚ïê‚ïê‚ïê ROUND ${state.round} - FIGHT! ‚ïê‚ïê‚ïê`, 'action');
        
        updateFightHUD();
        updatePunchStats();
        updateMomentum();
        updateDistance();
        showScreen('fight-screen');
    }

    function endFight(winner, method) {
        const state = GameState.fightState;
        const f1 = state.fighters[0];
        const f2 = state.fighters[1];
        
        // Play final bell
        playSound('bell');
        
        let winnerName, loserName;
        let winnerIndex = winner;
        
        if (winner === -1) {
            // Draw - small purse split for both
            document.getElementById('result-winner').textContent = 'IT\'S A DRAW!';
            document.getElementById('result-method').textContent = 'SPLIT DECISION';
            const drawPurse = 5000;
            GameState.players[0].money += drawPurse;
            GameState.players[1].money += drawPurse;
        } else {
            winnerName = state.fighters[winner].name;
            loserName = state.fighters[winner === 0 ? 1 : 0].name;
            
            document.getElementById('result-winner').textContent = winnerName + ' WINS!';
            document.getElementById('result-method').textContent = 'BY ' + method + (method.includes('KO') || method.includes('TKO') ? ' - ROUND ' + state.round : '');
            
            // Update records
            GameState.players[winner].wins++;
            GameState.players[winner === 0 ? 1 : 0].losses++;
            
            // Prize money - winner gets more, loser gets show money
            const basePrize = 10000;
            const roundBonus = state.round * 500;
            const koBonus = (method.includes('KO') || method.includes('TKO')) ? 5000 : 0;
            
            const winnerPrize = basePrize + roundBonus + koBonus;
            const loserPrize = Math.floor(basePrize * 0.3); // Show money
            
            GameState.players[winner].money += winnerPrize;
            GameState.players[winner === 0 ? 1 : 0].money += loserPrize;
        }
        
        // Build enhanced scorecard
        let scorecardHTML = '<div class="scorecard-row" style="border-bottom: 1px solid #333; padding-bottom: 8px; margin-bottom: 8px;"><span class="score-left">' + f1.name + '</span><span class="score-center">RND</span><span class="score-right">' + f2.name + '</span></div>';
        
        let p1Total = 0, p2Total = 0;
        state.scorecard.forEach(r => {
            const p1Style = r.p1 > r.p2 ? 'color: #00ff88; font-weight: bold;' : r.p1 < r.p2 ? 'color: #888;' : '';
            const p2Style = r.p2 > r.p1 ? 'color: #00ff88; font-weight: bold;' : r.p2 < r.p1 ? 'color: #888;' : '';
            scorecardHTML += `<div class="scorecard-row"><span class="score-left" style="${p1Style}">${r.p1}</span><span class="score-center">${r.round}</span><span class="score-right" style="${p2Style}">${r.p2}</span></div>`;
            p1Total += r.p1;
            p2Total += r.p2;
        });
        
        scorecardHTML += `<div class="scorecard-row" style="border-top: 2px solid #ffdd00; padding-top: 8px; margin-top: 8px;"><span class="score-left" style="font-size: 14px; color: ${p1Total > p2Total ? '#00ff88' : p1Total < p2Total ? '#e94560' : '#fff'};">${p1Total}</span><span class="score-center" style="font-size: 10px;">FINAL</span><span class="score-right" style="font-size: 14px; color: ${p2Total > p1Total ? '#00ff88' : p2Total < p1Total ? '#e94560' : '#fff'};">${p2Total}</span></div>`;
        
        document.getElementById('scorecard').innerHTML = scorecardHTML;
        
        // Calculate accuracy percentages
        const f1Accuracy = f1.punchesThrown > 0 ? Math.round((f1.punchesLanded / f1.punchesThrown) * 100) : 0;
        const f2Accuracy = f2.punchesThrown > 0 ? Math.round((f2.punchesLanded / f2.punchesThrown) * 100) : 0;
        
        // Enhanced stats display
        document.getElementById('result-stats').innerHTML = `
            <div class="panel">
                <p class="subtitle" style="text-align: center; margin-bottom: 10px;">${f1.name}</p>
                <div class="stat-row"><span>Total Punches:</span><span>${f1.punchesLanded}/${f1.punchesThrown} (${f1Accuracy}%)</span></div>
                <div class="stat-row"><span>Power Punches:</span><span>${f1.powerPunchesLanded || 0}</span></div>
                <div class="stat-row"><span>Body Shots:</span><span>${f1.bodyPunchesLanded || 0}</span></div>
                <div class="stat-row"><span>Combos Landed:</span><span>${f1.combosLanded || 0}</span></div>
                <div class="stat-row"><span>Knockdowns:</span><span style="color: ${f1.knockdowns > 0 ? '#e94560' : '#888'};">${f1.knockdowns}</span></div>
                <div class="stat-row"><span>Final Health:</span><span style="color: ${f1.health > 50 ? '#00ff88' : f1.health > 25 ? '#ffdd00' : '#e94560'};">${Math.round(f1.health)}%</span></div>
                <div class="stat-row"><span>Final Stamina:</span><span>${Math.round(f1.stamina)}%</span></div>
            </div>
            <div class="panel blue">
                <p class="subtitle" style="color: #4da6ff; text-align: center; margin-bottom: 10px;">${f2.name}</p>
                <div class="stat-row"><span>Total Punches:</span><span>${f2.punchesLanded}/${f2.punchesThrown} (${f2Accuracy}%)</span></div>
                <div class="stat-row"><span>Power Punches:</span><span>${f2.powerPunchesLanded || 0}</span></div>
                <div class="stat-row"><span>Body Shots:</span><span>${f2.bodyPunchesLanded || 0}</span></div>
                <div class="stat-row"><span>Combos Landed:</span><span>${f2.combosLanded || 0}</span></div>
                <div class="stat-row"><span>Knockdowns:</span><span style="color: ${f2.knockdowns > 0 ? '#e94560' : '#888'};">${f2.knockdowns}</span></div>
                <div class="stat-row"><span>Final Health:</span><span style="color: ${f2.health > 50 ? '#00ff88' : f2.health > 25 ? '#ffdd00' : '#e94560'};">${Math.round(f2.health)}%</span></div>
                <div class="stat-row"><span>Final Stamina:</span><span>${Math.round(f2.stamina)}%</span></div>
            </div>
        `;
        
        // Play crowd reaction
        setTimeout(() => playSound('crowd'), 500);
        
        showScreen('result-screen');
    }

    function returnToHub() {
        GameState.fightState = null;
        selectedP1Fighter = null;
        selectedP2Fighter = null;
        updateHubUI();
        showScreen('hub-screen');
        log('Fight complete! Back to franchise mode.', 'action');
    }

    // Standings
    function viewStandings() {
        const p1 = GameState.players[0];
        const p2 = GameState.players[1];
        
        let content = '<div style="text-align: center;">';
        content += '<p class="subtitle" style="margin-bottom: 15px;">MANAGER STANDINGS</p>';
        content += `<div class="scorecard-row"><span class="score-left">${p1.name}</span><span class="score-center">vs</span><span class="score-right">${p2.name}</span></div>`;
        content += `<div class="scorecard-row"><span class="score-left">${p1.wins} WINS</span><span class="score-center">-</span><span class="score-right">${p2.wins} WINS</span></div>`;
        content += `<div class="scorecard-row"><span class="score-left">$${p1.money.toLocaleString()}</span><span class="score-center">BANK</span><span class="score-right">$${p2.money.toLocaleString()}</span></div>`;
        content += '</div>';
        
        content += '<div class="divider"></div>';
        content += '<p class="subtitle" style="text-align: center;">SEASON ' + GameState.season + ' - WEEK ' + GameState.week + '/12</p>';
        
        document.getElementById('standings-content').innerHTML = content;
        showScreen('standings-screen');
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Brotherhood Boxing loaded!');
    });
    </script>
</body>
</html>
